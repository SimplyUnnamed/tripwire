Object.sort = function(obj, prop) {
	var swapped, prev;
	do {
		swapped = false, prev = null;
		for (var i in obj) {
			if (prev && Number(obj[i][prop]) < Number(obj[prev][prop])) {
				var tmp = obj[i];
				obj[i] = obj[prev];
				obj[prev] = tmp;
				swapped = true;
			}
			prev = i;
		}
	} while (swapped);
}

Object.index = function(obj, prop, val, cs) {
	for (var key in obj) {
		if (!cs && obj[key][prop] == val) {
			return key;
		} else if (obj[key][prop] && obj[key][prop].toLowerCase() == val.toLowerCase()) {
			return key;
		}
	}
}

Object.find = function(obj, prop, val, cs) {
	for (var key in obj) {
		if (!cs && obj[key][prop] == val) {
			return obj[key];
		} else if (obj[key][prop] && obj[key][prop].toLowerCase() == val.toLowerCase()) {
			return obj[key];
		}
	}

	return false;
}

Object.maxTime = function(obj, prop) {
	var maxTimeString = "", maxTime;

	for (var key in obj) {
		if (!maxTime || maxTime < new Date(obj[key][prop])) {
			maxTime = new Date(obj[key][prop]);
			maxTimeString = obj[key][prop];
		}
	}
	return maxTimeString;
}

Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }

    return size;
};

Object.time = function(obj) {
	var dates = [], key;
	for (key in obj) {
		dates.push(new Date(obj[key].time));
	}

	return dates.length ? dates.sort()[dates.length -1].getTime() /1000 : 0;
};

(function($){
    $.fn.serializeObject = function(){

        var self = this,
            json = {},
            push_counters = {},
            patterns = {
                "validate": /^[a-zA-Z][a-zA-Z0-9_]*(?:\[(?:\d*|[a-zA-Z0-9_]+)\])*$/,
                "key":      /[a-zA-Z0-9_]+|(?=\[\])/g,
                "push":     /^$/,
                "fixed":    /^\d+$/,
                "named":    /^[a-zA-Z0-9_]+$/
            };


        this.build = function(base, key, value){
            base[key] = value;
            return base;
        };

        this.push_counter = function(key){
            if(push_counters[key] === undefined){
                push_counters[key] = 0;
            }
            return push_counters[key]++;
        };

        $.each($(this).serializeArray(), function(){

            // skip invalid keys
            if(!patterns.validate.test(this.name)){
                return;
            }

            var k,
                keys = this.name.match(patterns.key),
                merge = this.value,
                reverse_key = this.name;

            while((k = keys.pop()) !== undefined){

                // adjust reverse_key
                reverse_key = reverse_key.replace(new RegExp("\\[" + k + "\\]$"), '');

                // push
                if(k.match(patterns.push)){
                    merge = self.build([], self.push_counter(reverse_key), merge);
                }

                // fixed
                else if(k.match(patterns.fixed)){
                    merge = self.build([], k, merge);
                }

                // named
                else if(k.match(patterns.named)){
                    merge = self.build({}, k, merge);
                }
            }

            json = $.extend(true, json, merge);
        });

        return json;
    };
})(jQuery);

var numFormat = function(num) {
	//Seperates the components of the number
	var n = num.toString().split(".");
	//Comma-fies the first part
	n[0] = n[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	//Combines the two sections
	return n.join(".");
};

var letterToNumbers = function(string) {
    string = string.toUpperCase();
    var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', sum = 0, i;
    for (i = 0; i < string.length; i++) {
        sum += Math.pow(letters.length, i) * (letters.indexOf(string.substr(((i + 1) * -1), 1)) + 1);
    }
    return sum;
};

var sigFormat = function(input, type) {
	if (!input) return "";

	var alpha = /^[a-zA-Z]+$/;
	var numeric = /^[0-9]+$/;
	var format = type == "type" ? options.chain.typeFormat || "" : options.chain.classFormat || "";

	for (var x = 0, l = format.length; x < l; x++) {
		if (format[x].match(alpha)) {
			if (format[x].toUpperCase() == "B" && input == "a") {
				return "";
			} else {
				if (format[x] == format[x].toUpperCase()) {
					format = format.substr(0, x) + input.toUpperCase() + format.substr(x + 1, l);
				} else {
					format = format.substr(0, x) + input + format.substr(x + 1, l);
				}
			}
		} else if (format[x].match(numeric)) {
			if (format[x] == 2 && input == "a") {
				return "";
			} else {
				format = format.substr(0, x) + letterToNumbers(input) + format.substr(x +1, l);
			}
		}
	}

	return format;
};

var isEmpty = function(obj) {
    for(var key in obj) {
        if(obj.hasOwnProperty(key))
            return false;
    }
    return true;
};

/** Find the relative position of one element within the hierarchy tree of another */
function positionRelativeTo(elem, ancestor) {
	const elemPos = elem.getBoundingClientRect(),
		ancestorPos = ancestor.getBoundingClientRect();
	return { 
		left: elemPos.left - ancestorPos.left + ancestor.scrollLeft,
		top: elemPos.top - ancestorPos.top + ancestor.scrollTop
	};
}

/** Look up one or more values in a comma separated string as keys in a data map, and return a property from the results in a new comma separated string.
Convenience function for UI mapping.
Will throw a failure message, unless suppress=true in which case it will return undefined, if 
any of the lookups fail to resolve. */
function lookupMultiple(map, propertyName, lookupString, suppress) {
	const values = lookupString.split(',');
	const results = [];
	for(var i = 0; i < values.length; i++) {
		const v = values[i];
		const r = map[v];
		if(!r) { 
			if(suppress) { return undefined;}
			else { throw 'Value ' + v + ' did not match anything in ' + map; }
		}
		results.push(r[propertyName]);
	}
	return results.join(',');
}

/** Look up one or more values in a comma separated string as property values in a data map, and return the key from the results in a new comma separated string.
Convenience function for UI mapping.
Will throw a failure message, unless suppress=true in which case it will return undefined, if 
any of the lookups fail to resolve. */
function lookupByPropertyMultiple(map, propertyName, lookupString, suppress) {
	const values = lookupString.split(',');
	const results = [];
	for(var i = 0; i < values.length; i++) {
		const v = values[i];
		const r = Object.index(map, propertyName, v);
		if(!r) { 
			if(suppress) { return undefined;}
			else { throw 'Value ' + v + ' did not match anything by property ' + propertyName + ' in ' + map; }
		}
		results.push(r);
	}
	return results.join(',');
}

var getCookie = function(c_name) {
	var c_value = document.cookie;

	var c_start = c_value.indexOf(" " + c_name + "=");
	if (c_start == -1) {
		c_start = c_value.indexOf(c_name + "=");
	}

	if (c_start == -1) {
		c_value = null;
	} else {
		c_start = c_value.indexOf("=", c_start) + 1;
		var c_end = c_value.indexOf(";", c_start);

		if (c_end == -1) {
			c_end = c_value.length;
		}

		c_value = unescape(c_value.substring(c_start, c_end));
	}

	return c_value;
};

var setCookie = function(c_name, value, exdays) {
	var exdate = new Date();
	exdate.setDate(exdate.getDate() + exdays);
	var c_value = escape(value) + ((exdays == null) ? "" : "; expires="+exdate.toUTCString());

	document.cookie = c_name + "=" + c_value + ";" + (document.location.protocol == "https:" ? "secure;" : "");
};

// Global CSS class change event
(function($) {
    var originalAddClassMethod = $.fn.addClass;
	var originalRemoveClassMethod = $.fn.removeClass;

    $.fn.addClass = function(className) {
        // Execute the original method.
        var result = originalAddClassMethod.apply(this, arguments);

        // trigger a custom event
        this.trigger('classchange', className);

        // return the original result
        return result;
    }

	$.fn.removeClass = function(className) {
        // Execute the original method.
        var result = originalRemoveClassMethod.apply(this, arguments);

        // trigger a custom event
        this.trigger('classchange', className);

        // return the original result
        return result;
    }
})(jQuery);

var parseHeaders = function(headers) {
		// Convert the header string into an array
		// of individual headers
		var arr = headers.trim().split(/[\r\n]+/);

		// Create a map of header names to values
		var headerMap = {};
		arr.forEach(function (line) {
				var parts = line.split(': ');
				var header = parts.shift();
				var value = parts.join(': ');
				headerMap[header] = value;
		});
		return headerMap;
}

var viewingSystem = $("meta[name=system]").attr("content");
var viewingSystemID = $("meta[name=systemID]").attr("content");
var server = $("meta[name=server]").attr("content");
var app_name = $("meta[name=app_name]").attr("content");
var version = $("meta[name=version]").attr("content");

// Page cache indicator
if (getCookie("loadedFromBrowserCache") == "true") {
	$("#pageTime").html("Page is Cached");
}

// setCookie('loadedFromBrowserCache', true);

// Use this to test performance of javascript code lines
// var startTime = window.performance.now();
// console.log("stint: "+ (window.performance.now() - startTime));

var options = new function() {
	var localOverrides = ["grid"];
	var localOptions = JSON.parse(localStorage.getItem("tripwire_options"));
	var saveTimer;

	this.userID = init.userID;
	this.character = {id: init.characterID, name: init.characterName};
	this.background = null;
	this.uiscale = 1.0;
	this.favorites = [];
	this.grid = {};
	this.tracking = {active: "new"};
	this.masks = {active: init.corporationID + ".2"};
	this.chain = {typeFormat: null, classFormat: null, gridlines: true, active: 0, tabs: [], "node-reference": "type", zoom: 1.0, sigNameLocation: 'name', routingLimit: 15, routeSecurity: 'shortest', routeIgnore: { enabled: false, systems: [ 'Tama', 'Rancer' ] }, renderer: 'orgChart' };
	this.signatures = {editType: "unknown", copySeparator: ",", pasteLife: 72, alignment: {sigID: "centerAlign", sigType: "centerAlign", sigAge: "centerAlign", leadsTo: "centerAlign", sigLife: "centerAlign", sigMass: "centerAlign"}};
	this.buttons = {follow: false, chainWidget: {viewing: false, favorites: false}, signaturesWidget: {autoMapper: false}};

	this.saveDelay = function(delay) {
		if (saveTimer) clearTimeout(saveTimer);

		saveTimer = setTimeout("options.save()", delay);
	};

	// Saves options in both cookie and database
	this.save = function() {
		var options = JSON.stringify(window.options.get());

		localStorage.setItem("tripwire_options", options);

		return $.ajax({
			url: "options.php",
			data: {mode: "set", options: options},
			type: "POST",
			dataType: "JSON"
		});
	};

	// Loads options via passed object else cookie
	this.load = function(data) {
		if (data && typeof(data) != "undefined") {
			this.set(this, data);
		} else if (localOptions) {
			this.set(this, localOptions);
		}

		this.apply();
	};

	// Gets options from this by exluding types == function
	this.get = function() {
		var data = {};

		for (var x in this) {
			if (typeof(this[x]) != "function") {
				data[x] = this[x];
			}
		}

		return data;
	};

	// Sets this from passed object
	this.set = function(local, data) {
		for (var prop in data) {
			if (data[prop] && data[prop].constructor && data[prop].constructor === Object) {
				if (local) {
					this.set(local[prop], data[prop]);
				}
			} else if (local && typeof(local[prop]) != "undefined") {
				local[prop] = data[prop];
			}
		}
	};

	this.reset = function() {
		for (var x in this) {
			if (typeof(this[x]) != "function") {
				this[x] = JSON.parse(JSON.stringify(this.reset.defaults[x]));
			}
		}
	};

	// Applies settings
	this.apply = function() {
		// Local browser overrides
		if (localOptions) {
            for (key in localOverrides) {
                this[localOverrides[key]] = localOptions[localOverrides[key]];
			}
		}

		// Grid layout (detect old IGB setting options)
		if (this.grid.hasOwnProperty("oog") && !isEmpty(this.grid.oog)) {
			$.each(this.grid.oog, function() {
				$("#"+this.id).attr({"data-col": this.col, "data-row": this.row, "data-sizex": this.size_x, "data-sizey": this.size_y})
					.css({width: this.width, height: this.height});
			});
		} else if (!isEmpty(this.grid)) {
			$.each(this.grid, function() {
				$("#"+this.id).attr({"data-col": this.col, "data-row": this.row, "data-sizex": this.size_x, "data-sizey": this.size_y})
					.css({width: this.width, height: this.height});
			});
		}

		// Make sure favorites are all ints and not strings
		this.favorites = $.map(this.favorites, function(favorite) {
			return parseInt(favorite);
		});

		// Buttons
		if (this.buttons.follow) $("#follow").addClass("active");
		if (this.buttons.chainWidget.home) $("#home").addClass("active");
		if (this.buttons.chainWidget.kspace) $("#k-space").addClass("active");
		if (this.buttons.chainWidget.viewing) $("#show-viewing").addClass("active");
		if (this.buttons.chainWidget.favorites) $("#show-favorite").addClass("active");
		if (this.buttons.chainWidget.evescout) $("#eve-scout").addClass("active");
		if ($.inArray(parseInt(viewingSystemID), this.favorites) !== -1) $("#system-favorite").attr("data-icon", "star").addClass("active");
		if (this.buttons.signaturesWidget.autoMapper) $("#toggle-automapper").addClass("active");

		// UI Scale
		if (this.uiscale) {
			$("body").css("zoom", this.uiscale);
		}

		// Chain zoom
		if (this.chain.zoom) {
			$("#chainParent").css("zoom", this.chain.zoom);
		}

		// Background
		if (this.background) {
			var a = $('<a>', { href:this.background } )[0];
			$("#wrapper").attr("style", "background-image: url(https://" + a.hostname + a.pathname + a.search + ");");
		} else {
			$("#wrapper").attr("style", "");
		}

		// Characters in Options
		$("#dialog-options #characters").html("<img src='https://image.eveonline.com/Character/"+init.characterID+"_64.jpg' />");

		// Active mask
		$("#dialog-options input[name='mask']").filter("[value='"+this.masks.active+"']").attr("checked", true);

		// Chain tabs
		$("#chainTabs").html("");
		for (var x in this.chain.tabs) {
			if (this.chain.tabs[x]) {
				var $tab = $("#chainTab .tab").clone();

				$tab.attr("id", x).find(".name").data("tab", this.chain.tabs[x].systemID).html(this.chain.tabs[x].name);
				if (x == this.chain.active) { $tab.addClass("current"); }

				$("#chainTabs").append($tab);
			}
		}

		// Draw chain if Tripwire is initialized
		if (typeof(tripwire) !== "undefined") {
			chain.redraw();
		}
	};

	this.reset.defaults = JSON.parse(JSON.stringify(this.get()));
	this.load(init && init.options ? init.options : null);
}

var grid = $(".gridster ul").gridster({
	widget_selector: "li.gridWidget",
	avoid_overlapped_widgets: false,
	widget_base_dimensions: [50, 50],
	widget_margins: [5, 5],
	autogrow_cols: true,
	helper: "clone",
	draggable: {
		start: function(e, ui) {
			$("div.gridster").width($("div.gridster ul").width());
		}
	},
	resize: {
    	enabled: true,
    	handle_class: "grid-resize",
    	max_size: [30, 30],
    	min_size: [4, 4],
    	start: function(e) {
    		$("div.gridster").width($("div.gridster ul").width());
    	},
    	stop: function(e, ui, $widget) {
    		//var width = parseInt($(".gridster").css("margin-left")) + this.container_width;
    		//$("#wrapper").css({width: width + "px"})
    		switch ($widget.attr("id")) {
    			case "infoWidget":
    				setTimeout("activity.redraw();", 300);
    				break;
    		}
    	}
	},
	serialize_params: function($w, wgd) {
		return {
			id: $w.attr("id"),
			col: wgd.col,
			row: wgd.row,
			size_x: wgd.size_x,
			size_y: wgd.size_y,
			width: $w.width(),
			height: $w.height()
		}
	}
}).data("gridster").disable();

grid.disable_resize();
$(".grid-resize").addClass("hidden").attr("data-icon", "resize");

$(".gridster").css({visibility: "visible"});
$(".gridster > *").addClass("gridster-transition");

$("#layout").click(function() {
	if (!$(this).hasClass("active")) {
		grid.enable();
		grid.enable_resize();
		$(".grid-resize").removeClass("hidden");

		$(this).addClass("active");
	} else {
		grid.disable();
		grid.disable_resize();
		$(".grid-resize").addClass("hidden");

		$(this).removeClass("active");

		options.grid = grid.serialize();

		options.save();
	}
});

var tripwire = new function() {
    this.timer, this.xhr;
	this.version = version;
	this.client = {signatures: {}, wormholes: {}};
	this.server = {signatures: {}, wormholes: {}};
	this.signatures = {list: {}, undo: JSON.parse(sessionStorage.getItem("tripwire_undo")) || {}, redo: JSON.parse(sessionStorage.getItem("tripwire_redo")) || {}};
	this.serverSignatureCount = 0;
	this.activity = {};
	this.data = {tracking: {}, esi: {}};
	this.refreshRate = 5000;
	this.connected = true;
	this.ageFormat = "HM";
	this.instance = window.name ? window.name : (new Date().getTime() / 1000, window.name = new Date().getTime() / 1000);

    // Command to start/stop tripwire updates
	// ToDo: Include API and Server timers
	this.stop = function() {
		clearTimeout(this.timer);
		return this.timer;
	};

	this.start = function() {
		return this.sync();
	}

    // Command to change Age format
	// ToDo: Cookie change to keep
	this.setAgeFormat = function(format) {
		var format = typeof(format) !== 'undefined' ? format : this.ageFormat;

		$("span[data-age]").each(function() {
			$(this).countdown("option", {format: format});
		});

		return true;
	}

    this.serverTime = function() {
		this.time;

		this.serverTime.getTime = function() {
			return tripwire.serverTime.time;
		}
	}
    this.serverTime();

    // Handles putting chain together
	this.chainMap = function() {
		this.chainMap.parse = function(data) {
			chain.draw(data);
		}
	}
    this.chainMap();

    this.pastEOL = function() {
		var options = {since: $(this).countdown('option', 'until'), format: "HM", layout: "-{hnn}{sep}{mnn}&nbsp;"};
		$(this).countdown("option", options);
	}

    // Handles WH Type hover-over tooltip
	// ToDo: Use native JS
	this.whTooltip = function(sig) {
		if (viewingSystemID == sig.systemID) {
			if ($.inArray(sig.type, $.map(tripwire.wormholes, function(item, index) { return index;})) >= 0) {
				var type = sig.type;
				var tooltip = '';
			} else {
				var type = sig.sig2Type;
				var tooltip = "<b>Type:</b> "+type+"<br/>";
			}
		} else {
			if ($.inArray(sig.sig2Type, $.map(tripwire.wormholes, function(item, index) { return index;})) >= 0) {
				var type = sig.sig2Type;
				var tooltip = '';
			} else {
				var type = sig.type;
				var tooltip = "<b>Type:</b> "+type+"<br/>";
			}
		}

		if ($.inArray(type, $.map(tripwire.wormholes, function(item, index) { return index;})) >= 0) {
			var whType = true;
		} else {
			var whType = false;
		}

		tooltip += "<b>Life:</b> "+(whType?tripwire.wormholes[type].life:"Unknown")+"<br/>";

		if (whType) {
			switch (tripwire.wormholes[type].leadsTo.split(" ")[0]) {
				case 'High-Sec':
					tooltip += "<b>Leads To:</b> <span class='hisec'>"+tripwire.wormholes[type].leadsTo+"</span><br/>";
					break;
				case 'Low-Sec':
					tooltip += "<b>Leads To:</b> <span class='lowsec'>"+tripwire.wormholes[type].leadsTo+"</span><br/>";
					break;
				case 'Null-Sec':
					tooltip += "<b>Leads To:</b> <span class='nullsec'>"+tripwire.wormholes[type].leadsTo+"</span><br/>";
					break;
				case 'Class':
					tooltip += "<b>Leads To:</b> <span class='wh'>"+tripwire.wormholes[type].leadsTo+"</span><br/>";
					break;
				default:
					tooltip += "<b>Leads To:</b> <span>"+tripwire.wormholes[type].leadsTo+"</span><br/>";
			}
		} else {
			tooltip += "<b>Leads To:</b> <span>Unknown</span><br/>";
		}

		tooltip += "<b>Max Mass</b>: "+(whType?numFormat(tripwire.wormholes[type].mass):"Unknown")+" Kg<br/>";

		tooltip += "<b>Max Jumpable</b>: "+(whType?numFormat(tripwire.wormholes[type].jump):"Unknown")+" Kg<br/>";

		return tooltip;
	}

	// Handles Age hover-over tooltip
	// ToDo: Use native JS
	this.ageTooltip = function(sig) {
		// var date = new Date(sig.lifeTime);
		// var localOffset = date.getTimezoneOffset() * 60000;
		// date = new Date(date.getTime() + localOffset);
        var date = new Date(sig.lifeTime);

		var tooltip = "<table class=\"age-tooltip-table\"><tr>"
        + "<th>Created:</th><td>"+(date.getMonth()+1)+"/"+date.getDate()+" "+(date.getHours() < 10?'0':'')+date.getHours()+":"+(date.getMinutes() < 10?'0':'')+date.getMinutes()+"</td>"
        + "<td>"+sig.createdByName.replace(/'/g, '&#39;').replace(/"/g, '&#34;')+"</td>"
        + "</tr>";

		if (sig.lifeTime != sig.modifiedTime) {
			date = new Date(sig.modifiedTime);
			// localOffset = date.getTimezoneOffset() * 60000;
			// date = new Date(date.getTime() + localOffset);
      
			tooltip += "<tr><th>Last Modified:</th><td>"+(date.getMonth()+1)+"/"+date.getDate()+" "+(date.getHours() < 10?'0':'')+date.getHours()+":"+(date.getMinutes() < 10?'0':'')+date.getMinutes()+"</td>"
          + "<td>"+sig.modifiedByName.replace(/'/g, '&#39;').replace(/"/g, '&#34;')+"</td>"
          + "</tr>";
		}

		tooltip += "</table>";

		return tooltip;
	}

    this.refresh = function(mode, data, successCallback, alwaysCallback) {
		var mode = mode || 'refresh';

		this.sync(mode, data, successCallback, alwaysCallback);
	}
}

$("body").on("click", "a[href^='.?system=']", function(e) {
	e.preventDefault();

	var system = $(this).attr("href").replace(".?system=", "");
	var systemID = Object.index(tripwire.systems, "name", system);

	tripwire.systemChange(systemID);
});

$("body").on("submit", "#systemSearch", function(e) {
	e.preventDefault();

	var system = $(this).find("[name='system']").val();
	var systemID = Object.index(tripwire.systems, "name", system, true) || false;

	if (systemID !== false) {
		tripwire.systemChange(systemID);
		$(this).find("[name='system']").val("");
		$("#search").click();
	}
});

$("body").on("click", "#undo:not(.disabled)", function() {
	tripwire.undo();
});

$("body").on("click", "#redo:not(.disabled)", function() {
	tripwire.redo();
});

// Chain map zooming (Gets funky if you push things too far)
$("#chainParent").on("mousewheel", function(e) {
	e.preventDefault();
	var zoom = parseFloat($("#chainParent").css("zoom")) || 1.0;
	var min = 0.6;
	var max = 2.0;

    if (e.originalEvent.wheelDelta / 120 > 0 && zoom < max) {
		$("#chainParent").css("zoom", zoom + 0.1);
    } else if (e.originalEvent.wheelDelta / 120 < 0 && zoom > min) {
		$("#chainParent").css("zoom", zoom - 0.1);
    }

	// Show the reset zoom button for awhile
	$("#chain-zoom-reset").fadeIn(200);
	if (this.timeout) clearTimeout(this.timeout);
	this.timeout = setTimeout('$("#chain-zoom-reset").fadeOut(200);', 3000);

	// Save options
	options.chain.zoom = parseFloat($("#chainParent").css("zoom"));
	options.saveDelay(2000);
});

$("#chain-zoom-reset").on("click", function() {
	$("#chainParent").css("zoom", 1);
	options.chain.zoom = 1;
	options.saveDelay(2000);
});

$(document).keydown(function(e)	{
	//Abort - user is in input or textarea
	if ($(document.activeElement).is("textarea, input")) return;

	// Ctrl key hooks
	if (e.metaKey || e.ctrlKey) {

		if (e.keyCode === 89 && !$("#redo").hasClass("disabled")) {
			// Ctrl-y redo hook
			e.preventDefault();
			$("#redo").click();
			Notify.trigger("Redoing last undo");
		} else if (e.keyCode === 90 && !$("#undo").hasClass("disabled")) {
			// Ctrl-z undo hook
			e.preventDefault();
			$("#undo").click();
			Notify.trigger("Undoing last action");
		} else if (e.keyCode === 65) {
			// Ctrl-a select all (signatures) hook
			e.preventDefault();
			$("#sigTable tbody tr").addClass("selected");
			$("#signaturesWidget #delete-signature").trigger("delete:refresh");
		} else if (e.keyCode === 67) {
			// Ctrl-c copy selected signatures hook
			if (window.getSelection().toString() === "") {
				var output = "";
				$("#sigTable tbody tr.selected").each(function(row) {
					var signature = tripwire.client.signatures[$(this).data("id")];
					var row = [];

					if (signature.signatureID) {
						row.push(signature.signatureID.substring(0, 3).toUpperCase() + "-" + (signature.signatureID.substring(3, 6) || "###"));
					} else {
						row.push("null");
					}

					row.push(signature.type);
					if (signature.type === "wormhole") {
						var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
						var otherSignature = signature.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID];
						row.push(wormhole.type || "null" );
						row.push(tripwire.systems[signature.systemID] ? tripwire.systems[signature.systemID].name : tripwire.aSigSystems[signature.systemID]);
						row.push(tripwire.systems[otherSignature.systemID] ? tripwire.systems[otherSignature.systemID].name : tripwire.aSigSystems[otherSignature.systemID]);
						row.push(wormhole.life);
						row.push(wormhole.mass);
					} else {
						row.push(signature.name);
					}

					row.push(signature.createdByName);
					row.push(signature.lifeTime);
					row.push(signature.lifeLength);
					row.push(signature.lifeLeft);
					row.push(signature.modifiedByName);
					row.push(signature.modifiedTime);
					output += row.join(options.signatures.copySeparator) + "\r\n";
				});
				$("#clipboard").text(output);
				$("#clipboard").focus();
				$("#clipboard").select();
			}
		}
	} else {
		// delete key keyhooks
		if (e.keyCode == 46 && $("#sigTable tr.selected").length > 0) {
			$("#delete-signature").click();
		}
	}
});

// $("#APIclock").knob({angleArc: 359.9, height: 20, width: 20, max: 60, readOnly: true, displayInput: false, fgColor: "#CCC", bgColor: "#666"});

$("#follow").click(function(e) {
	e.preventDefault();

	if ($(this).hasClass("active"))
		$(this).removeClass("active");
	else
		$(this).addClass("active");

	options.buttons.follow = $(this).hasClass("active");
	options.save();
})

$("#show-viewing").click(function() {
	if ($(this).hasClass("active"))
		$(this).removeClass("active");
	else
		$(this).addClass("active");

	chain.redraw();

	options.buttons.chainWidget.viewing = $(this).hasClass("active");
	options.save();
});

$("#show-favorite").click(function() {
	if ($(this).hasClass("active"))
		$(this).removeClass("active");
	else
		$(this).addClass("active");

	chain.redraw();

	options.buttons.chainWidget.favorites = $(this).hasClass("active");
	options.save();
});

$("#system-favorite").click(function() {
	if ($(this).hasClass("active")) {
		$(this).removeClass("active").attr("data-icon", "star-empty");

		options.favorites.splice(options.favorites.indexOf(parseInt(viewingSystemID)), 1);
	} else {
		$(this).attr("data-icon", "star").addClass("active");

		options.favorites.push(parseInt(viewingSystemID));
	}

	if ($("#show-favorite").hasClass("active"))
		chain.redraw();

	options.save();
});

$("#search").click(function(e) {
	$("#searchSpan").toggle();

	if ($(this).hasClass("active")) {
		$(this).removeClass("active");
		if (tripwire.client.EVE && tripwire.client.EVE.systemName)
			$("#currentSpan").show();
	} else {
		$(this).addClass("active");
		$("#currentSpan").hide();

		$("#searchSpan input[name=system]").focus().select();
	}
});

$("#toggle-automapper").click(function(e) {
	e.preventDefault();

	if ($(this).hasClass("active")) {
		$(this).removeClass("active");
	} else {
		$(this).addClass("active");
	}

	options.buttons.signaturesWidget.autoMapper = $(this).hasClass("active");
	options.save();
});

$("#track").on("click", ".tracking-clone", function() {
	var characterID =$(this).attr("data-characterid");
	$("#tracking .tracking-clone").removeClass("active");

	if (options.tracking.active == characterID) {
		options.tracking.active = null;
		tripwire.EVE(false, true);
		$("#removeESI").attr("disabled", "disabled");
	} else {
		options.tracking.active = characterID;

		if (tripwire.esi.characters[options.tracking.active]) {
			$("#tracking .tracking-clone[data-characterid='"+ options.tracking.active +"']").addClass("active");
			tripwire.EVE(tripwire.esi.characters[options.tracking.active], true);
		}

		$("#removeESI").removeAttr("disabled");
	}

	options.save();
});

$("#login").on("click", "#removeESI", function() {
	var characterID = options.tracking.active;

	options.tracking.active = null;
	tripwire.EVE(false, true);
	options.save();

	$("#tracking .tracking-clone[data-characterid='"+ characterID +"']").remove();

	$("#removeESI").attr("disabled", "disabled");

	if ($.isArray(tripwire.data.esi.delete)) {
		tripwire.data.esiDelete.push(characterID);
	} else {
		tripwire.data.esiDelete = [characterID];
	}
});

$("#user").click(function(e) {
	e.preventDefault();

	if ($(this).hasClass("active")) {
		$(this).removeClass("active");

		$("#login > #panel").css({display: "none"});

		//$("#wrapper").unbind("click");
	} else {
		$(this).addClass("active");

		$("#login > #panel").css({display: "inline"});
		$("#loginForm input[name=username]").focus().select();

		// Click outside closes
		$("#wrapper").click(function(e) {
			$("#login > #panel").css({display: "none"});
			$("#user").removeClass("active");
		});

		$("#login").click(function(e) {
			e.stopPropagation();
		})
	}
});

$("#logout").click(function() {
	window.location = "logout.php";
});

var Notify = new function() {
	this.trigger = function(content, color, stick, id) {
		var color = typeof(color) !== "undefined" ? color : "blue";
		var stick = typeof(stick) !== "undefined" ? stick : 10000;
		var id = typeof(id) !== "undefined" ? id : null;

		new jBox("Notice", {
			id: id,
			content: content,
			offset: {y: 35},
			animation: "flip",
			color: color,
			autoClose: stick
		});
	}
}

// Init valdiation tooltips
var ValidationTooltips = new jBox("Tooltip", {
	trigger: null,
	addClass: "validation-tooltip",
	animation: "flip",
	fade: 0
});

var Tooltips = new jBox("Tooltip", {
	attach: $("[data-tooltip]"),
	getContent: "data-tooltip",
	position: {x: "right", y: "center"},
	outside: "x"
});

var SystemActivityToolTips = new jBox("Tooltip", {
	getContent: "data-tooltip",
	position: {y: "bottom"},
	appendTo: $("#chainParent"),
	reposition: true,
	repositionOnOpen: true,
	createOnInit: true,
	onOpen: function() {
		var targetPos = positionRelativeTo(this.target[0], document.getElementById('chainParent'));
		var nodePos = this.source.closest("[data-nodeid]").position();
		var parentPos = this.source.closest(".nodeActivity").position();
		var nodeHeight = this.source.closest("[data-nodeid]").height();
		// var nodeWidth = this.source.closest("[data-nodeid]").width();
		var tooltipWidth = this.container.parent().width();
		// var tooltipHeight = this.container.parent().height();

		this.options.position = {x: targetPos.left + 3 - tooltipWidth /2 , y: targetPos.top + this.target[0].offsetHeight};
	}
});

var WormholeRouteToolTips = new jBox("Tooltip", {
	getContent: "data-tooltip",
	position: {y: "bottom"},
	appendTo: $("#chainParent"),
	reposition: true,
	repositionOnOpen: true,
	createOnInit: true,
	onOpen: function() {
		var targetPos = positionRelativeTo(this.target[0], document.getElementById('chainParent'));
		var nodeHeight = this.source.closest("[data-nodeid]").height();
		// var nodeWidth = this.source.closest("[data-nodeid]").width();
		var tooltipWidth = this.container.parent().width();
		// var tooltipHeight = this.container.parent().height();
		
		this.options.position = {x: targetPos.left + 3 - tooltipWidth /2 , y: targetPos.top + this.target[0].offsetHeight};
	}
});

var WormholeTypeToolTips = new jBox("Tooltip", {
	attach: $("#chainMap .whEffect[data-icon]"),
	getContent: "data-tooltip",
	position: {x: "left", y: "center"},
	appendTo: $("#chainParent"),
	outside: "x",
	adjustDistance: 100,
	responsiveWidth: false,
	reposition: true,
	repositionOnOpen: true,
	createOnInit: true,
	onOpen: function() {
		var targetPos = positionRelativeTo(this.target[0], document.getElementById('chainParent'));
		var tooltipWidth = this.container.parent().width();

		this.options.position = {x: targetPos.left - tooltipWidth - 10, y: targetPos.top - 3};
	}
});

var OccupiedToolTips = new jBox("Tooltip", {
	pointer: "top:-3",
	position: {x: "right", y: "center"},
	appendTo: $("#chainParent"),
	outside: "x",
	minWidth: 100,
	animation: "move",
	adjustDistance: 100,
	responsiveWidth: false,
	reposition: true,
	repositionOnOpen: true,
	repositionOnContent: true,
	createOnInit: true,
	onOpen: function() {
		var tooltip = this;
		const nodeElemJ = this.source.closest("[data-nodeid]");
		var systemID = nodeElemJ.data("nodeid");
		var targetPos = positionRelativeTo(this.target[0], document.getElementById('chainParent'));

		this.options.position = {x: targetPos.left + this.target[0].offsetWidth, y: targetPos.top - 3};

		tooltip.setContent("&nbsp;");

		$.ajax({
			url: "occupants.php",
			dataType: "JSON",
			data: "systemID="+systemID,
			cache: false
		}).done(function(data) {
			if (data && data.occupants) {
				var chars = "<table>";

				// Sort by characterName
				data.occupants.sort(function(a, b) {
					if (a.characterName.toLowerCase() < b.characterName.toLowerCase()) return -1;
					if (a.characterName.toLowerCase() > b.characterName.toLowerCase()) return 1;
					return 0;
				});

				for (var x in data.occupants) {
					chars += "<tr><td>"+data.occupants[x].characterName+"</td><td style='padding-left: 10px;'>"+(data.occupants[x].shipTypeName?data.occupants[x].shipTypeName:"")+"</td></tr>";
				}

				chars += "</table>";
				tooltip.setContent(chars);
			}
		});
	}
});

$("#chainTabs").sortable({
	items: "> .tab",
	axis: "x",
	delay: 150,
	tolerance: "pointer",
	containment: "parent",
	update: function(e, ui) {
		var result = $("#chainTabs").sortable("toArray");
		var newTabs = [];

		for (var x in result) {
			newTabs.push(options.chain.tabs[result[x]]);
			$("#chainTabs .tab:eq("+x+")").attr("id", x);
		}

		options.chain.active = $(".tab.current").index();
		options.chain.tabs = newTabs;
		options.save();
	}
});

$("#chainTabs").on("click", ".tab", function(e) {
	e.preventDefault();
	chain.setActiveTab($(this).hasClass("current") ? null : $(this).index())
});

$("#chainTabs").on("click", ".closeTab", function(e) {
	e.stopPropagation();
	var $tab = $(this).closest(".tab");

	$("#dialog-confirm #msg").html("This tab will be removed, are you sure?");
	$("#dialog-confirm").dialog("option", {
		buttons: {
			"Remove Tab": function() {
				var i = $tab.index();

				options.chain.active = $(".tab.current").index();
				options.chain.tabs.splice(i, 1);
				options.save();

				$tab.remove();
				if ($("#chainTabs .tab.current").length == 0) {
					$("#chainTabs .tab:last").click();
				}

				for (var x = 0, l = $("#chainTabs .tab").length; x < l; x++) {
					$("#chainTabs .tab:eq("+x+")").attr("id", x);
				}

				$(this).dialog("close");
			},
			Cancel: function() {
				$(this).dialog("close");
			}
		}
	}).dialog("open");
});

$("#newTab").on("click", function() {
	// check if dialog is open
	if (!$("#dialog-newTab").hasClass("ui-dialog-content")) {
		$("#dialog-newTab").dialog({
			resizable: false,
			minHeight: 0,
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				OK: function() {
					$("#newTab_form").submit();
				},
				Cancel: function() {
					$(this).dialog("close");
				}
			},
			open: function() {
				$("#dialog-newTab .name").val(viewingSystem).focus();
				$("#dialog-newTab .sigSystemsAutocomplete").val(viewingSystem);
			},
			close: function() {
				ValidationTooltips.close();
			},
			create: function() {
				$("#dialog-newTab .sigSystemsAutocomplete").inlinecomplete({source: tripwire.aSigSystems, maxSize: 10, delay: 0});

				$("#newTab_form").submit(function(e) {
					e.preventDefault();
					var $tab = $("#chainTab .tab").clone();
					var name = $("#dialog-newTab .name").val();
					var systemID = lookupByPropertyMultiple(tripwire.systems, "name", $("#dialog-newTab .sigSystemsAutocomplete").val(), true);
					var thera = $("#tabThera")[0].checked ? true : false;

					if (!name) {
						ValidationTooltips.open({target: $("#dialog-newTab .name")}).setContent("Must have a name!");
						return false;
					} else if (!systemID && $("#tabType1")[0].checked) {
						ValidationTooltips.open({target: $("#dialog-newTab .sigSystemsAutocomplete")}).setContent("Must have valid systems (comma separated if multiple)!");
						return false;
					} else if ($("#tabType2")[0].checked) {
						systemID = 0;
					}

					$tab.attr("id", $("#chainTabs .tab").length).find(".name").data("tab", systemID).html(name);
					options.chain.tabs.push({systemID: systemID, name: name, evescout: thera});
					options.save();

					$("#chainTabs").append($tab);

					$("#dialog-newTab").dialog("close");
				});

				$("#dialog-newTab .sigSystemsAutocomplete").click(function(e) {
					$("#dialog-newTab #tabType1").click();
				});
			}
		});
	} else if (!$("#dialog-newTab").dialog("isOpen")) {
		$("#dialog-newTab").dialog("open");
	}
});

$("#chainTabs").on("click", ".editTab", function(e) {
	e.stopPropagation();

	// check if dialog is open
	if (!$("#dialog-editTab").hasClass("ui-dialog-content")) {
		$("#dialog-editTab").dialog({
			resizable: false,
			minHeight: 0,
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				OK: function() {
					$("#editTab_form").submit();
				},
				Cancel: function() {
					$(this).dialog("close");
				}
			},
			open: function() {
				$("#dialog-editTab .name").val(options.chain.tabs[options.chain.active].name).focus();
				$("#dialog-editTab .sigSystemsAutocomplete").val(options.chain.tabs[options.chain.active].systemID != 0 ? lookupMultiple(tripwire.systems, 'name', options.chain.tabs[options.chain.active].systemID) : "");
				options.chain.tabs[options.chain.active].systemID != 0 ? $("#dialog-editTab #editTabType1")[0].checked = true : $("#dialog-editTab #editTabType2")[0].checked = true;
				$("#dialog-editTab #editTabThera")[0].checked = options.chain.tabs[options.chain.active].evescout;
			},
			close: function() {
				ValidationTooltips.close();
			},
			create: function() {
				$("#dialog-editTab .sigSystemsAutocomplete").inlinecomplete({source: tripwire.aSigSystems, maxSize: 10, delay: 0});

				$("#editTab_form").submit(function(e) {
					e.preventDefault();
					var $tab = $("#chainTabs .tab").eq([options.chain.active]);
					var name = $("#dialog-editTab .name").val();
					var systemID = lookupByPropertyMultiple(tripwire.systems, "name", $("#dialog-editTab .sigSystemsAutocomplete").val(), true);
					var thera = $("#editTabThera")[0].checked ? true : false;

					if (!name) {
						ValidationTooltips.open({target: $("#dialog-editTab .name")}).setContent("Must have a name!");
						return false;
					} else if (!systemID && $("#editTabType1")[0].checked) {
						ValidationTooltips.open({target: $("#dialog-editTab .sigSystemsAutocomplete")}).setContent("Must have valid systems (comma separated if multiple)!");
						return false;
					} else if ($("#editTabType2")[0].checked) {
						systemID = 0;
					}

					$tab.attr("id", $("#chainTabs .tab").length).find(".name").data("tab", systemID).html(name);
					options.chain.tabs[options.chain.active] = {systemID: systemID, name: name, evescout: thera};
					options.save();
					chain.redraw();

					tripwire.parse(tripwire.client, "refresh");

					//$("#chainTabs").append($tab);

					$("#dialog-editTab").dialog("close");
				});

				$("#dialog-editTab .sigSystemsAutocomplete").click(function(e) {
					$("#dialog-editTab #editTabType1").click();
				});
			}
		});
	} else if (!$("#dialog-editTab").dialog("isOpen")) {
		$("#dialog-editTab").dialog("open");
	}
});

// Signature column context menu
$("#signaturesWidget #sigTable thead").contextmenu({
	delegate: "th.sortable",
	menu: "#signatureColumnMenu",
	position: function(event, ui) {
        return {my: "left top", at: "center", of: ui.target};
    },
	select: function(e, ui) {
		var col = $(ui.target).parent().parent().children().index($(ui.target).parent()) + 1;

		switch(col) {
			case 1:
				colName = "sigID";
				break;
			case 2:
				colName = "sigType";
				break;
			case 3:
				colName = "sigAge";
				break;
			case 4:
				colName = "leadsTo";
				break;
			case 5:
				colName = "sigLife";
				break;
			case 6:
				colName = "sigMass";
				break;
		}

		switch(ui.cmd) {
			case "leftAlign":
				$("#signaturesWidget #sigTable tbody td:nth-child("+ col +")").removeClass("centerAlign rightAlign").addClass("leftAlign");
				options.signatures.alignment[colName] = "leftAlign";
				break;
			case "centerAlign":
				$("#signaturesWidget #sigTable tbody td:nth-child("+ col +")").removeClass("leftAlign rightAlign").addClass("centerAlign");
				options.signatures.alignment[colName] = "centerAlign";
				break;
			case "rightAlign":
				$("#signaturesWidget #sigTable tbody td:nth-child("+ col +")").removeClass("centerAlign leftAlign").addClass("rightAlign");
				options.signatures.alignment[colName] = "rightAlign";
				break;
		}

		options.save();
	},
	beforeOpen: function(e, ui) {
		var col = $(ui.target).parent().parent().children().index($(ui.target).parent()) + 1;

		switch(col) {
			case 1:
				colName = "sigID";
				break;
			case 2:
				colName = "sigType";
				break;
			case 3:
				colName = "sigAge";
				break;
			case 4:
				colName = "leadsTo";
				break;
			case 5:
				colName = "sigLife";
				break;
			case 6:
				colName = "sigMass";
				break;
		}

		$(this).contextmenu("enableEntry", "leftAlign", true);
		$(this).contextmenu("enableEntry", "centerAlign", true);
		$(this).contextmenu("enableEntry", "rightAlign", true);

		$(this).contextmenu("enableEntry", options.signatures.alignment[colName], false);
	}
});

// Chain Map Context Menu
$("#chainParent").contextmenu({
	appendTo: "#chainParent",
	delegate: ".nodeSystem a",
	position: function(event, ui) {
        return {my: "left top-1", at: "right top", of: ui.target};
    },
	menu: "#chainMenu",
	show: {effect: "slideDown", duration: 150},
	select: function(e, ui) {
		const nodeElem = $(ui.target[0]).closest("[data-nodeid]");
		var id = nodeElem.data("nodeid");
		var row = nodeElem.attr("id").replace("node", "") -1;

		switch(ui.cmd) {
			case "showInfo":
				tripwire.esi.showInfo(id, options.tracking.active);
				break;
			case "setDest":
				tripwire.esi.setDestination(id, options.tracking.active, true);
				break;
			case "addWay":
				tripwire.esi.setDestination(id, options.tracking.active, false);
				break;
			case "showMap":
				// CCPEVE.showMap(id);
				break;
			case "red":
				nodeElem.hasClass("redNode") ? $(this).contextmenu("removeFlare", id, ui) : $(this).contextmenu("setFlare", id, ui.cmd, ui);
				break;
			case "yellow":
				nodeElem.hasClass("yellowNode") ? $(this).contextmenu("removeFlare", id, ui) : $(this).contextmenu("setFlare", id, ui.cmd, ui);
				break;
			case "green":
				nodeElem.hasClass("greenNode") ? $(this).contextmenu("removeFlare", id, ui) : $(this).contextmenu("setFlare", id, ui.cmd, ui);
				break;
			case "mass":
				$("#dialog-mass").data("id", nodeElem.data("sigid")).data("systemID", id).dialog("open");
				break;
			case "ping":
				$("#dialog-ping").data("id", nodeElem.data("sigid") || null).data("systemID", id).dialog("open");
				break;
			case "collapse":
				var toggle = options.chain.tabs[options.chain.active] ? ($.inArray(id, options.chain.tabs[options.chain.active].collapsed) == -1 ? true : false) : true;
				chain.renderer.collapse(id, toggle);
				break;
			case "makeTab":
				const existingTabIndex = Object.index(options.chain.tabs, 'systemID', '' + id, false);
				if(undefined !== existingTabIndex) {
					chain.setActiveTab(existingTabIndex);
				} else {
					const systemName = tripwire.systems[id].name;
					options.chain.tabs.push({systemID: '' + id, name: systemName});
					var newTab = $("#chainTab .tab").clone();
					newTab.attr('id', options.chain.tabs.length - 1).find(".name").data("tab", id).html(systemName);
					$("#chainTabs").append(newTab);
					chain.setActiveTab(options.chain.tabs.length - 1);
				}
				break;
		}
	},
	beforeOpen: function(e, ui) {
		var wormholeID = $(ui.target[0]).closest("[data-nodeid]").data("sigid") || null;
		var systemID = $(ui.target[0]).closest("[data-nodeid]").data("nodeid");

		// Add check for k-space
		if (tripwire.systems[systemID].class || !tripwire.esi.characters[options.tracking.active]) {
			$(this).contextmenu("enableEntry", "setDest", false);
			$(this).contextmenu("enableEntry", "addWay", false);
			$(this).contextmenu("enableEntry", "showMap", false);
		} else {
			$(this).contextmenu("enableEntry", "setDest", true);
			$(this).contextmenu("enableEntry", "addWay", true);
			$(this).contextmenu("enableEntry", "showMap", false);
		}
		
		// Add check for in-sig
		if (wormholeID) {
			$(this).contextmenu("enableEntry", "mass", true);
		} else {
			$(this).contextmenu("enableEntry", "mass", false);
		}
		
		// Add check for tab validity
		const existingTab = Object.find(options.chain.tabs, 'systemID', '' + systemID, false);
		$('#makeTabMenuItem').text(existingTab ? 'View Tab' : 'Make Tab' );
	},
	create: function(e, ui) {
		// Fix some bad CSS from jQuery Position
		$(this).find(".ui-front").css("width", "10em");
		$(this).find(".ui-front").css("position", "");

		$("#dialog-mass").dialog({
			autoOpen: false,
			width: "auto",
			height: "auto",
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				Close: function() {
					$(this).dialog("close");
				}
			},
			open: function() {
				var wormholeID = $(this).data("id");
				var systemID = $(this).data("systemID");
				var wormhole = tripwire.client.wormholes[wormholeID];
				var signature = tripwire.client.signatures[wormhole.initialID];
				var otherSignature = tripwire.client.signatures[wormhole.secondaryID];

				$("#dialog-mass").dialog("option", "title", "From "+tripwire.systems[signature.systemID].name+" to "+tripwire.systems[otherSignature.systemID].name);

				$("#dialog-mass #massTable tbody tr").remove();

				var payload = {wormholeID: wormhole.id};

				$.ajax({
					url: "mass.php",
					type: "POST",
					data: payload,
					dataType: "JSON"
				}).done(function(data) {
					if (data && data.mass) {
                        var totalMass = 0;
						for (x in data.mass) {
                            totalMass += parseFloat(data.mass[x].mass);
							$("#dialog-mass #massTable tbody").append("<tr><td>"+data.mass[x].characterName+"</td><td>"+(data.mass[x].toID == systemID ? "In" : "Out")+"</td><td>"+data.mass[x].shipType+"</td><td>"+numFormat(data.mass[x].mass)+"Kg</td><td>"+data.mass[x].time+"</td></tr>");
						}
                        $("#dialog-mass #massTable tbody").append("<tr><td></td><td></td><td></td><th>"+ numFormat(totalMass) +"Kg</th><td></td></tr>");
					}
				});
			}
		});

		$.moogle.contextmenu.prototype.setFlare = function(systemID, flare, ui) {
			var data = {"systemID": systemID, "flare": flare};

			$.ajax({
				url: "flares.php",
				type: "POST",
				data: data,
				dataType: "JSON"
			}).done(function(data) {
				if (data && data.result) {
					// $(ui.target[0]).closest("td").removeClass("redNode yellowNode greenNode").addClass(flare+"Node");

					chain.data.flares.flares.push({systemID: systemID, flare: flare, time: null});
					chain.flares(chain.data.flares);
				}
			});
		}

		$.moogle.contextmenu.prototype.removeFlare = function(systemID, ui) {
			var data = {"systemID": systemID};

			$.ajax({
				url: "flares.php",
				type: "POST",
				data: data,
				dataType: "JSON"
			}).done(function(data) {
				if (data && data.result) {
					// $(ui.target[0]).closest("td").removeClass("redNode yellowNode greenNode");

					chain.data.flares.flares.splice(Object.index(chain.data.flares.flares, "systemID", systemID), 1);
					chain.flares(chain.data.flares);
				}
			});
		}
	}
});

// Used to generate eve-survival guide link
function linkSig(sigName) {
	var wormholeSignatures = [
		// Ore sites
		"Average Frontier Deposit",
		"Unexceptional Frontier Deposit",
		"Common Perimeter Deposit",
		"Exceptional Core Deposit",
		"Infrequent Core Deposit",
		"Unusual Core Deposit",
		"Rarified Core Deposit",
		"Isolated Core Deposit",
		"Ordinary Permiter Deposit",
		"Uncommon Core Deposit",

		// Gas Sites
		"Barren Perimeter Reservoir",
		"Minor Perimeter Reservoir",
		"Ordinary Perimeter Reservoir",
		"Sizeable Perimeter Reservoir",
		"Token Perimeter Reservoir",
		"Bountiful Frontier Reservoir",
		"Vast Frontier Reservoir",
		"Instrumental Core Reservoir",
		"Vital Core Reservoir",

		// Class 1
		"Perimeter Ambush Point",
		"Perimeter Camp",
		"Phase Catalyst Node",
		"The Line",
		"Forgotten Perimeter Coronation Platform",
		"Forgotten Perimeter Power Array",
		"Unsecured Perimeter Amplifier",
		"Unsecured Perimeter Information Center",

		// Class 2
		"Perimeter Checkpoint",
		"Perimeter Hangar",
		"The Ruins of Enclave Cohort 27",
		"Sleeper Data Sanctuary",
		"Forgotten Perimeter Gateway",
		"Forgotten Perimeter Habitation Coils",
		"Unsecured Perimeter Comms Relay",
		"Unsecured Perimeter Transponder Farm",

		// Class 3
		"Fortification Frontier Stronghold",
		"Outpost Frontier Stronghold",
		"Solar Cell",
		"The Oruze Construct",
		"Forgotten Frontier Quarantine Outpost",
		"Forgotten Frontier Recursive Depot",
		"Unsecured Frontier Database",
		"Unsecured Frontier Receiver",

		// Class 4
		"Frontier Barracks",
		"Frontier Command Post",
		"Integrated Terminus",
		"Sleeper Information Sanctum",
		"Forgotten Frontier Conversion Module",
		"Forgotten Frontier Evacuation Center",
		"Unsecured Frontier Digital Nexus",
		"Unsecured Frontier Trinary Hub",

		// Class 5
		"Core Garrison",
		"Core Stronghold",
		"Oruze Osobnyk",
		"Quarantine Area",
		"Forgotten Core Data Field",
		"Forgotten Core Information Pen",
		"Unsecured Frontier Enclave Relay",
		"Unsecured Frontier Server Bank",

		// Class 6
		"Core Citadel",
		"Core Bastion",
		"Strange Energy Readings",
		"The Mirror",
		"Forgotten Core Assembly Hall",
		"Forgotten Core Circuitry Disassembler",
		"Unsecured Core Backup Array",
		"Unsecured Core Emergence"
	];

	if (wormholeSignatures.indexOf(sigName) > -1) {
		return '<a href="http://eve-survival.org/wikka.php?wakka='+sigName.replace(/ /g, '')+'" target="_blank" class="siteLink">'+sigName+'</a>';
	}

	return sigName;
}

// Custom inlinecomplete + dropdown input
$.widget("custom.inlinecomplete", $.ui.autocomplete, {
	_create: function() {
		if (!this.element.is("input")) {
			this._selectInit();
		}

		// Invoke the parent function
		return this._super();
	},
	_value: function() {
		// Invoke the parent function
		var originalReturn = this._superApply(arguments);

		this.element.change();

		return originalReturn;
	},
	_suggest: function(items) {
		// if (this.element.val() != items[0].value) {
			// this.element.val(items[0].value.substr(0, this.element.val().length));
		// }

		// Invoke the parent function
		return this._super(items);
	},
	_initSource: function() {
		if ($.isArray(this.options.source)) {
			this.source = function(request, response) {
				var matcher = new RegExp("^" + $.ui.autocomplete.escapeRegex(request.term), "i");
				var results = new Array(); // results array
				var data = this.options.source;
				var maxSize = this.options.maxSize || 25; // maximum result size
				// simple loop for the options
				for (var i = 0, l = data.length; i < l; i++) {
					if (matcher.test(data[i])) {
						results.push(data[i]);

						if (maxSize && results.length > maxSize) {
							break;
						}
					}
				}
				 // send response
				 response(results);
			}
		} else {
			// Invoke the parent function
			return this._super();
		}
	},
	_close: function(event) {
		this.options.source = this.options.input_source ? this.options.input_source : this.options.source;

		// Invoke the parent function
		return this._super(event);
	},
	addToSelect: function(value) {
		this.options.select_added_value = value;
		this.options.select_source.unshift(value);
	},
	removeFromSelect: function(value) {
		if (value) {
			this.options.select_source.splice(value, 1);
		} else if (this.options.select_added_value) {
			this.options.select_source.splice(this.options.select_added_value, 1);
		}
		this.options.select_added_value = null;
	},
	_selectInit: function() {
		this.element.addClass("custom-combobox");
		this.wrapper = this.element;
		this.element = this.wrapper.find("input:first");
		this.select = this.wrapper.find("select:first").remove();

		this.options.input_source = this.options.source;
		this.options.select_source = this.select.children("option[value!='']").map(function() {
            return $.trim(this.text);
        }).toArray();

		this._createShowAllButton();
	},
	_createShowAllButton: function() {
        var that = this,
          wasOpen = false;

        $("<a>")
			.attr("tabIndex", that.element.prop("tabindex"))
			.attr("title", "")
			.appendTo(that.wrapper)
			.button({icons: {primary: "ui-icon-triangle-1-s"}, text: false})
			.removeClass("ui-corner-all")
			.addClass("custom-combobox-toggle ui-corner-right")
			.on("mousedown", function() {
				wasOpen = that.widget().is(":visible");
			})
			.on("click", function() {
				that.element.trigger("focus");

				// Close if already visible
				if (wasOpen) {
				  return;
				}

				// Pass empty string as value to search for, displaying all results
				that.options.source = that.options.select_source;
				that._search("");
			});
	},
});

// Initialize tablesorter plugin on signaturesWidget table
$("#sigTable").tablesorter({
	sortReset: true,
	widgets: ['saveSort'],
	textExtraction: {
		2: function(node) { return $(node).find("span").data("age"); }
	}
});

// Highlight signaturesWidget tr on click
$("#sigTable tbody").on("click", "tr", function(e) {
	if (e.metaKey || e.ctrlKey) {
		// ctrl or cmd key
		$(this).toggleClass("selected");
	} else if (e.shiftKey) {
		// shift key
		$(this).addClass("selected");
		$("#sigTable tbody tr.selected:first").nextUntil("#sigTable tbody tr.selected:last").addBack().add("#sigTable tbody tr.selected:last").addClass("selected");
	} else {
		$("#sigTable tbody tr.selected").removeClass("selected");
		$(this).addClass("selected");
	}
});

// Un-Highlight signaturesWidget tr on clicking outside
$(document).click(function(e) {
    if(!$(e.target).closest('#sigTable tbody').length && !$(e.target).closest('#edit-signature').length && !$(e.target).closest('#delete-signature').length) {
		$("#sigTable tbody tr.selected").removeClass("selected");
    }
});

// Monitor custom 'classchange' event
$("#sigTable tbody").on("classchange", "tr", function(e, className) {
	// Trigger signaturesWidget selected row change custom event
	if (className === "selected") {
		$("#signaturesWidget").trigger("selected:change");
	}
});

// Update signaturesWidget based on .selected rows change
$("#signaturesWidget").on("selected:change", function() {
	// Enable/Disable delete icon
	if ($("#sigTable tr.selected").length === 0) {
		$("#signaturesWidget #delete-signature").addClass("disabled");
	} else {
		$("#signaturesWidget #delete-signature").removeClass("disabled");
	}

	// Enable/Disable edit icon
	if ($("#sigTable tr.selected").length === 1) {
		$("#signaturesWidget #edit-signature").removeClass("disabled");
	} else {
		$("#signaturesWidget #edit-signature").addClass("disabled");
	}
})

$("#dialog-error").dialog({
	autoOpen: false,
	resizable: false,
	minHeight: 0,
	dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
	buttons: {
		Ok: function() {
			$(this).dialog("close");
		}
	},
	create: function() {
		$(this).dialog("option", "show", {effect: "shake", duration: 150, easing: "easeOutElastic"});
	}
});

$("#dialog-msg").dialog({
	autoOpen: false,
	resizable: false,
	minHeight: 0,
	dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
	buttons: {
		Ok: function() {
			$(this).dialog("close");
		}
	}
});

$("#dialog-confirm").dialog({
	autoOpen: false,
	resizable: false,
	minHeight: 0,
	dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
	buttons: {
		Cancel: function() {
			$(this).dialog("close");
		}
	}
});

if (window.location.href.indexOf("galileo") != -1) {
	Notify.trigger("This is the test version of Tripwire.<br/>Please use <a href='https://tripwire.cloud-things.com'>Tripwire</a>")
}

const systemAnalysis = new function() {
	const mutators = [];
	this.addMutator = function(m) { mutators.push(m); }
	
	/** Extract attributes of the system, and allow mutators to add/modify them.
		Optionally, pass in a system object */
	this.analyse = function(systemID, system) {
		if(!system) { system = tripwire.systems[systemID]; }
		if(!system) { return system; }
		const r = Object.assign({}, system);
		
		// Defaults or saved original values
		r.baseSecurity = 1 * system.security;
		r.pathSymbol = '';
		r.systemTypeModifiers = [];		
		
		mutators.forEach(function(m) { m.mutate(r, systemID); });
		
		// Calculated final values
		r.systemTypeClass = r.class ? 'wh class-' + r.class :
			r.factionID == 500026 ? 'triglavian' :
			r.security >= 0.45 ? 'hisec' :
			r.security > 0.0 ? 'lowsec' :
			r.security <= 0.0 ? 'nullsec' :
			'unknown';
		r.systemTypeName = r.class ? 'C' + r.class :
			r.factionID == 500026 ? 'Trig' :
			r.baseSecurity >= 0.45 ? 'HS' :
			r.baseSecurity > 0.0 ? 'LS' :
			r.baseSecurity <= 0.0 ? 'NS' :
			'';
			
		return r;
	};

}
var guidance = (function (undefined) {

	var extractKeys = function (obj) {
		var keys = [];

		for (var key in obj) {
		    Object.prototype.hasOwnProperty.call(obj,key) && keys.push(key);
		}

		return keys;
	}

	var sorter = function (a, b) {
		return parseFloat (a) - parseFloat (b);
	}

	function adjustCostForOptions(mapCost, system) {
		var system = systemAnalysis.analyse(30000000 + 1 * system);
		if(!system) { return mapCost; }
		if(options.chain.routeIgnore.enabled && options.chain.routeIgnore.systems.indexOf(system.name) >= 0) {
			mapCost += 100;	// Penalty for an avoided system
		}
		switch(options.chain.routeSecurity) {
			case 'highsec': return mapCost + (system.security < 0.45 ? 100 : 0);
			case 'avoid-high': return mapCost + (system.security >= 0.45 ? 100 : 0);
			case 'avoid-null': return mapCost + (system.security <= 0.0 ? 100 : 0);
			default: return mapCost;	// in case of some invalid option, default to shortest
		}
	}

	var findPaths = function (map, start, end, infinity) {
		infinity = infinity || Infinity;

		var costs = {},
		    open = {'0': [start]},
		    predecessors = {},
		    keys;

		var addToOpen = function (cost, vertex) {
			var key = "" + cost;
			if (!open[key]) open[key] = [];
			open[key].push(vertex);
		}

		costs[start] = 0;

		while (open && !costs[end]) {
			if(!(keys = extractKeys(open)).length) break;

			keys.sort(sorter);

			var key = keys[0],
			    bucket = open[key],
			    node = bucket.shift(),
			    currentCost = parseFloat(key),
			    adjacentNodes = map[node] || {};

			if (!bucket.length) delete open[key];

			for (var vertex in adjacentNodes) {
			    if (Object.prototype.hasOwnProperty.call(adjacentNodes, vertex)) {
					var cost = adjustCostForOptions(adjacentNodes[vertex], vertex),
					    totalCost = cost + currentCost,
					    vertexCost = costs[vertex];

					if ((vertexCost === undefined) || (vertexCost > totalCost)) {
						costs[vertex] = totalCost;
						addToOpen(totalCost, vertex);
						predecessors[vertex] = node;
					}
				}
			}
		}

		if (costs[end] === undefined) {
			return null;
		} else {
			return predecessors;
		}

	}

	var extractShortest = function (predecessors, end) {
		var nodes = [],
		    u = end;

		while (u) {
			nodes.push(u);
			predecessor = predecessors[u];
			u = predecessors[u];
		}

		nodes.reverse();
		return nodes;
	}

	var findShortestPath = function (map, nodes) {
		var start = nodes.shift(),
		    end,
		    predecessors,
		    path = [],
		    shortest;

		while (nodes.length) {
			end = nodes.shift();
			predecessors = findPaths(map, start, end);

			if (predecessors) {
				shortest = extractShortest(predecessors, end);
				if (nodes.length) {
					path.push.apply(path, shortest.slice(0, -1));
				} else {
					return path.concat(shortest);
				}
			} else {
				return null;
			}

			start = end;
		}
	}

	var toArray = function (list, offset) {
		try {
			return Array.prototype.slice.call(list, offset);
		} catch (e) {
			var a = [];
			for (var i = offset || 0, l = list.length; i < l; ++i) {
				a.push(list[i]);
			}
			return a;
		}
	}

	var Guidance = function (map) {
		this.map = map;
	}

	Guidance.prototype.findShortestPath = function (start, end) {
		var result;

		if (Object.prototype.toString.call(start) === '[object Array]') {
			result = findShortestPath(this.map, start);
		} else if (arguments.length === 2) {
			result = findShortestPath(this.map, [start, end]);
		} else {
			result = findShortestPath(this.map, toArray(arguments));
		}

		return result;
	}

	Guidance.findShortestPath = function (map, start, end) {
		if (Object.prototype.toString.call(start) === '[object Array]') {
			return findShortestPath(map, start);
		} else if (arguments.length === 3) {
			return findShortestPath(map, [start, end]);
		} else {
			return findShortestPath(map, toArray(arguments, 1));
		}
	}

	return Guidance;
})();

const thera = new _TheraConnection();

function _TheraConnection() {
	const _this = this;
	
	this.links = [];
	
	this.active = function() {
		return options.chain.tabs[options.chain.active] && options.chain.tabs[options.chain.active].evescout;
	}
	
	this.nodeNameSuffix = 'eve-scout-thera';
	
	this.findLinks = function(systemID, ids) {
		if(!_this.active()) { return; }
		
		const r = [];
		for(var ti = 0; ti < this.links.length; ti++) {
			var theraNode;
			const theraLink = this.links[ti];
			const theraID = 'T-' + theraLink.id;
			
			const nodeDefaults = {
				life: theraLink.wormholeEol,
				mass: theraLink.wormholeMass,
				id: theraID,
			};
			
			if(theraLink.solarSystemId == systemID) {	// Connection from this hole
				r.push(Object.assign({
					
					parent: {
						id: ids.parentID,
						systemID: systemID,
						signatureID: theraLink.wormholeDestinationSignatureId,
						type: theraLink.sourceWormholeType.name,
					},	child: {
						id: ids.nextChildID++,
						systemID: theraLink.wormholeDestinationSolarSystemId,
						signatureID: theraLink.signatureId,
						type: theraLink.destinationWormholeType.name,								
					}
				}, nodeDefaults));
			} else if(theraLink.wormholeDestinationSolarSystemId == systemID) { // Connection to this hole
				r.push(Object.assign({
					parent: {
						id: ids.parentID,
						systemID: systemID,
						signatureID: theraLink.signatureId,
						type: theraLink.destinationWormholeType.name,
					},	child: {
						id: ids.nextChildID++,
						systemID: theraLink.solarSystemId,
						signatureID: theraLink.wormholeDestinationSignatureId,
						type: theraLink.sourceWormholeType.name,								
					}
				}, nodeDefaults));				
			}
		}
		
		return r;
	}
	
	/** Refresh the Thera data from the public Eve-Scout API */
	this.refresh = function() {
		if(!_this.active()) {
			return;	// only look for Thera data if on a tab with the option selected
		}
		
		$.ajax({
			url: `https://api.allorigins.win/get?url=${encodeURIComponent('https://www.eve-scout.com/api/wormholes')}`,
			type: "GET",
			dataType: "JSON"
		}).done(function(data, status, xhr) {	
            const wormholes = JSON.parse(data.contents);
			if(!_.isEqual(wormholes, _this.links)) {
                
				console.info('Updating map for Thera update');
				_this.links = wormholes;
				chain.redraw();
			}
		}).fail(function(xhr, status, error) {
			console.warn('Failed to fetch Thera from eve-scout.com: ' + status, error);
		});
	};
	
	setInterval(this.refresh, 60000);
	this.refresh();
}
const ChainMapRendererOrgchart = function(owner) {
	const _this = this;
	
	/** Initialiser - callback from chart onload */
	this.init = function() {
		_this.map = new google.visualization.OrgChart(document.getElementById("chainMap"));
		_this.options = {allowHtml: true, allowCollapse: true, size: "medium", nodeClass: "node"};

		google.visualization.events.addListener(_this.map, "collapse", _this.collapseHandler);

		_this.map.draw(new google.visualization.DataView(new google.visualization.DataTable({cols:[{label: "System", type: "string"}, {label: "Parent", type: "string"}]})), _this.options);
	}
	
	/** Is this renderer ready to accept draw calls? */
	this.ready = function() { return !this.drawing && !!this.map; }
	
	/** Switch to this renderer. The renderer can be in a blank state; draw() will be called after */
	this.switchTo = function() {
		document.getElementById('chainGrid').style.display = '';
		if(!_this.map) { google.charts.setOnLoadCallback(this.init); }
	}
	
	/** Switch away from this renderer. All node divs should be removed from the DOM */
	this.switchFrom = function() {
		document.getElementById('chainGrid').style.display = 'none';
		_this.map.draw(new google.visualization.DataView(new google.visualization.DataTable({cols:[{label: "System", type: "string"}, {label: "Parent", type: "string"}]})), _this.options);		
	}
	
	/** Redraw the map, based on the given node set, line overrides and list of collapsed systems */
	this.draw = function(map, lines, collapsed) {
		this.drawing = true;
		this.map.draw(newView(map), this.options); 
		
		for (var x in collapsed) {
			const s = collapsed[x];
			const nodeId = $("#chainMap [data-nodeid='"+s+"']").attr("id");
			if (nodeId) {
				const nodeVal = nodeId.split("node")[1];
				this.map.collapse(nodeVal - 1, true);
			}
		}
		
		updateLines(map, lines);
		this.drawing = false;
	};
	
	const newView = function(json) {
		const view = new google.visualization.DataView(new google.visualization.DataTable(json));
		return view;
	};
	
	const updateLines = function(map, lines) {
		_this.lastLineData = { map: map, lines: lines };
		function drawNodeLine(system, parent, mode, signatureID) {
			/*	function for drawing colored lines  */
			if(typeof mode == 'string') { mode = [mode]; }

			function addModes(jquerySelector, prefixes) { return doModeClasses(jquerySelector, prefixes, function(s, c) { s.addClass(c); }); }
			function removeModes(jquerySelector, prefixes) { return doModeClasses(jquerySelector, prefixes, function(s, c) { s.removeClass(c); }); }
			function doModeClasses(jquerySelector, prefixes, classFunc) {
				prefixes = prefixes || [];
				prefixes.push('');
				prefixes.forEach(function(prefix) { 
					mode.forEach( function(mode) { classFunc(jquerySelector, (prefix.length ? prefix + '-' : '') + mode); });
				});
				return jquerySelector;
			}

			// Find node in chainmap
			//var $node = $("#chainMap [data-nodeid='"+system+"']").parent();
			var $node = $("#chainMap #node"+system).parent();

			if ($node.length == 0) {
				return false;
			}

			// Get node # in this line
			var nodeIndex = Math.ceil(($node[0].cellIndex + 1) / 2 - 1);

			// applly to my top line
			var $connector = addModes($($node.parent().prev().children("td.google-visualization-orgchart-lineleft, td.google-visualization-orgchart-lineright")[nodeIndex]), [ 'left', 'right' ]);

			// Find parent node
			//var $parent = $("#chainMap [data-nodeid='"+parent+"']").parent();
			var $parent = $("#chainMap #node"+parent).parent();

			if ($parent.length == 0 || $connector.length == 0)
				return false;

			// Find the col of my top line
			var nodeCol = 0, connectorCell = $connector[0].cellIndex;
			$node.parent().prev().find("td").each(function(index) {
				nodeCol += this.colSpan;

				if (index == connectorCell) {
					return false;
				}
			});

			// Get node # in this line
			var parentIndex = Math.ceil(($parent[0].cellIndex + 1) / 2 - 1);

			// Compensate for non-parent nodes (slight performance hit ~10ms)
			var newparentIndex = parentIndex;
			for (var i = 0; i <= parentIndex; i++) {
				var checkSystem = 0;//$node.parent().prev().prev().prev().find("td:has([data-nodeid]):eq("+i+")").find("[data-nodeid]").data("nodeid");
				$node.parent().prev().prev().prev().find("td > [data-nodeid]").each(function(index) {
					if (index == i) {
						checkSystem = $(this).attr("id").replace("node", "");//$(this).data("nodeid");

						return false;
					}
				});

				if ($.map(map.rows, function(node) { return node.c[1].v == checkSystem ? node : null; }).length <= 0) {
					newparentIndex--;
				}
			}
			parentIndex = newparentIndex;

			// Apply to parent bottom line
			var $connecte = addModes($($node.parent().prev().prev().children("td.google-visualization-orgchart-lineleft, td.google-visualization-orgchart-lineright")[parentIndex]), [ 'left', 'right'] );

			// the beans
			var col = 0, parent = false, me = false;
			$node.parent().prev().prev().find("td").each(function(index, value) {
				col += this.colSpan;

				if (me && parent) {
					// All done - get outta here
					return false;
				} else if (typeof($connecte[0]) != "undefined" && $connecte[0].cellIndex == index) {
					parent = true;

					addModes($(this), ['left']);

					// remove bottom border that points to the right
					if (!me && col != nodeCol) {
						addModes($(this), ['bottom']);
					}

					// parent and node are same - we are done
					if (nodeCol == col) {
						return false;
					}
				} else if (col == nodeCol) {
					me = true;

					addModes($(this), [ 'bottom' ]);
				} else if (me || parent) {
					var tempCol = 0, breaker = false, skip = false;

					$node.parent().prev().find("td").each(function(index) {
						tempCol += this.colSpan;

						if (tempCol == col && ($(this).hasClass("google-visualization-orgchart-lineleft") || $(this).hasClass("google-visualization-orgchart-lineright"))) {
							if (parent == false) {
								// Stop looking cuz there is another node between us and parent
								breaker = true;
								removeModes($connecte, [ 'left', 'right' ]);
								return false;
							} else if (parent == true) {
								// Lets make sure there isnt a node between the parent and me
								removeModes($connecte, [ 'left', 'right' ]);

								$node.parent().prev().prev().find("td").each(function(index) {
									if (index >= $connecte[0].cellIndex) {
										// there is a node after parent but before me
										removeModes($(this), [ 'bottom' ]);
									}
								});
								skip = true;
							}
						}
					});

					if (breaker) {
						return false;
					}

					if (!skip) {
						addModes($(this), ['bottom'] );
					}
				}
			});
		}

		for (var x in lines) {
			drawNodeLine(lines[x][0], lines[x][1], lines[x][2], lines[x][3]);
		}
	};

	this.collapseHandler = function() {		
		if(_this.drawing) { return; }
		
		const collapsed = _this.map.getCollapsedNodes();
		const collapsedSystems = [];
		for (x in collapsed) {
			var systemID = $("#chainMap #node"+(collapsed[x] +1)).data("nodeid");
			collapsedSystems.push(systemID);
		}
		owner.updateCollapsed(collapsedSystems);
		
		if(_this.lastLineData) { updateLines(_this.lastLineData.map, _this.lastLineData.lines); }
	}


};
const ChainMapRendererRadial = function(owner) {
	/** Is this renderer ready to accept draw calls? */
	this.ready = function() { return !this.drawing; }
	
	/** Switch to this renderer. The renderer can be in a blank state; draw() will be called after */
	this.switchTo = function() {
		if(!document.getElementById('map-container')) {
			const newDiv = document.createElement('div');
			newDiv.id = 'map-container';
			newDiv.className = 'radial-map';
			document.getElementById('chainMap').appendChild(newDiv);
		}
		this.container = document.getElementById('map-container');
		this.container.style.display = '';
	}
	
	/** Switch away from this renderer. All node divs should be removed from the DOM */
	this.switchFrom = function() {
		const div = document.getElementById('map-container');
		if(div) { div.parentNode.removeChild(div); }
		this.container = null;
	}
	
	this.collapse = function(systemID, collapse) {
		if(collapse) { this.mapData.collapsed.push(systemID); }
		else {  this.mapData.collapsed = this.mapData.collapsed.filter(x => x != systemID); }
		owner.updateCollapsed(this.mapData.collapsed);
		drawInner(this.mapData.map, this.mapData.lines, this.mapData.collapsed);
	}
	
	/** Redraw the map, based on the given node set, line overrides and list of collapsed systems */
	this.draw = function(map, lines, collapsed) {
		this.drawing = true;
		this.mapData = {map: map, lines: lines, collapsed: collapsed};
		
		// Clear the map for a new one
		//this.switchFrom(); this.switchTo();

		try { drawInner(map, lines, collapsed); }
		finally { this.drawing = false; }
	}
	
	const CIRCLE_SIZE = { x: 70, y: 60, first_ring_delta: 0.3,
		ringX: function(ci) { return ci == 0 ? 0 : (ci + this.first_ring_delta) * this.x},
		ringY: function(ci) { return ci == 0 ? 0 : (ci + this.first_ring_delta) * this.y},
	 };

	const _this = this;
	const drawInner = function(map, lines, collapsed) {
		const maps = [];
		const nodesById = {};
		
		// First pass: arrange nodes into rings
		for(var ri = 0; ri < map.rows.length; ri++) {
			const item = map.rows[ri];
			const inNode = item.c[0], id = inNode.v, parent = item.c[1].v;
			
			const mapNode = { id: id, children: [], systemID: inNode.systemID, minArc: 0 };
			
			if(parent == null) {
				const newMap =  { circles: [ { arc: 0, nodes: [ mapNode ] } ] };
				mapNode.map = newMap;
				mapNode.circle = 0;
				maps.push(newMap);
			} else {
				const parentNode = nodesById[parent];
				if(!parentNode) { throw 'Parent id ' + parent + ' not on map yet'; }
				parentNode.children.push(mapNode);
				mapNode.parent = parentNode;
				mapNode.connection = lines.filter(function(l) { return l[0] == id; })[0] || [id, parent, [], '?'];
				mapNode.connection[2].unshift('connection');
				mapNode.map = parentNode.map;
				mapNode.circle = parentNode.circle + 1;
				if(mapNode.map.circles.length <= mapNode.circle) {
					mapNode.map.circles.push({ arc: 0, nodes:[mapNode] });
				} else { mapNode.map.circles[mapNode.circle].nodes.push(mapNode); }
			}
			nodesById[id] = mapNode;
			mapNode.markup = inNode.f;
		}

		// Second pass - for each map, find the allocation of arc needed for each node
		for(var mi = 0; mi < maps.length; mi++) {
			const map = maps[mi];
			for(var ci = map.circles.length - 1; ci >= 1; ci--) {	// don't need to calculate ring 0
				for(var ni = 0; ni < map.circles[ci].nodes.length; ni++) {
					const node = map.circles[ci].nodes[ni];
					node.minArc *= ci / (ci + 1.0);
					if(node.minArc < 1 || collapsed.indexOf(node.systemID * 1) >= 0) { node.minArc = 1; }
					node.parent.minArc += node.minArc;
					map.circles[ci].arc += node.minArc;
				}
			}
		}

		// Third pass - lay out each ring based on the arc values
		for(var mi = 0; mi < maps.length; mi++) {
			const map = maps[mi];
			var mapDiv = document.getElementById("map" + mi);
			if(!mapDiv) {
				mapDiv = document.createElement('div');
				mapDiv.id = "map" + mi;
				mapDiv.className = "map-chain-wrapper";
			}
			mapDiv.innerHTML = '<div class="map-outer-container"><div class="map-inner-container"><canvas class="map-drawing" id="map-canvas-' + mi + '"/></div></div>';
			const innerContainer = mapDiv.firstChild.firstChild;
			document.getElementById('map-container').appendChild(mapDiv);

			map.bounds = makeDivsForRing(innerContainer, 0, map.circles[0].nodes, 0, Math.PI * 2, collapsed);
			map.domNode = mapDiv;
			map.innerContainer = innerContainer;
		}

		// Fourth pass: update div and canvas bounds, and draw rings/links
		const CANVAS_SCALE = 1;
		for(var mi = 0; mi < maps.length; mi++) {
			const map = maps[mi];
			const finalPositions = {
				w: 200 + map.bounds.x[1] - map.bounds.x[0],
				h: 100 + map.bounds.y[1] - map.bounds.y[0],
				cx: 100 - map.bounds.x[0],
				cy: 50 - map.bounds.y[0]
			}
			
			// Fill the space available, if we didn't already
			if(maps.length == 1) {
				const parentWidth = -38 + _this.container.offsetWidth;	// 20px for map margins, 18 for scrollbar
				if(finalPositions.w < parentWidth) {
					finalPositions.cx += 0.5 * (parentWidth - finalPositions.w);
					finalPositions.w = parentWidth;
				}
			}			
			const parentHeight = document.getElementById('chainParent').offsetHeight;
			if(finalPositions.h < parentHeight) {
				finalPositions.cy += 0.5 * (parentHeight - finalPositions.h);
				finalPositions.h = parentHeight;
			}
			
			// If there's enough space to centre the top level node now, do it
			if(finalPositions.h >= 2 * (map.bounds.y[1] > -map.bounds.y[0] ? map.bounds.y[1] : -map.bounds.y[0])) {
				finalPositions.cy = finalPositions.h / 2;
			}
			if(finalPositions.w >= 2 * (map.bounds.x[1] > -map.bounds.x[0] ? map.bounds.x[1] : -map.bounds.x[0])) {
				finalPositions.cx = finalPositions.w / 2;
			}			
			map.domNode.style.width = finalPositions.w + 'px';
			map.domNode.style.height = finalPositions.h + 'px';
			const outerContainer = map.domNode.firstChild;
			outerContainer.style.left = finalPositions.cx + 'px';
			outerContainer.style.top = finalPositions.cy + 'px';
			const canvas = outerContainer.getElementsByTagName('canvas')[0];
			canvas.width = CANVAS_SCALE * finalPositions.w;
			canvas.style.width = finalPositions.w + 'px';
			canvas.height = CANVAS_SCALE * finalPositions.h;
			canvas.style.height = finalPositions.h + 'px';
			canvas.style.left = -finalPositions.cx + 'px';
			canvas.style.top = -finalPositions.cy + 'px';
			const ctx = canvas.getContext('2d');
			ctx.scale(CANVAS_SCALE, CANVAS_SCALE);
			ctx.translate(finalPositions.cx, finalPositions.cy);
				
			for(var ci = map.bounds.maxCi; ci >= 1; ci--) {	// don't need to draw ring 0
				if(options.chain.gridlines) {
					ctx.beginPath();
					if(ctx.ellipse) {
						ctx.lineWidth = 0.5;
						ctx.setLineDash([]);
						ctx.ellipse(0, 0, CIRCLE_SIZE.ringX(ci), CIRCLE_SIZE.ringY(ci), 0, 0, Math.PI * 2);
					}
					ctx.strokeStyle = propertyFromCssClass('grid-default', 'color');
					ctx.stroke();		
				}
				if(ci >= map.circles.length) { continue; }
				
				for(var ni = 0; ni < map.circles[ci].nodes.length; ni++) {
					const node = map.circles[ci].nodes[ni];
					if(!node.position) { continue; }	// not drawn on map
					ctx.beginPath();
					ctx.lineWidth = node.connection[2].reduce(function(w, c) { return c == 'frig' ? 1 : w; }, 3);
					ctx.moveTo(node.position.x, node.position.y);
					const cp1 = radToCartesian({ r: node.radPosition.r - 0.5, theta: (node.radPosition.theta + 2 * node.parent.radPosition.theta) / 3.0 });
					const cp2 = radToCartesian({ r: node.radPosition.r - 0.5, theta: (2 * node.radPosition.theta + node.parent.radPosition.theta) / 3.0 });
					
					if(ci > 1) {				
						ctx.bezierCurveTo(cp2.x, cp2.y, cp1.x, cp1.y, node.parent.position.x, node.parent.position.y);
					} else {
						ctx.lineTo(node.parent.position.x, node.parent.position.y);			
					}
					const dist2 = (node.position.y - node.parent.position);
					ctx.strokeStyle = propertyFromCssClass(node.connection[2], 'border-top-color');
					ctx.setLineDash ({ dashed: [3, 2] }[propertyFromCssClass(node.connection[2], 'border-top-style')] || []);
					ctx.stroke();
				}
			}	
		}
		
		// Remove any maps which aren't in use any more
		for(var mi = maps.length; ; mi++) {
			const div = document.getElementById('map' + mi);
			if(div) { div.parentNode.removeChild(div); }
			else { break; }
		}
	}
	
	function makeDivsForRing(innerContainer, ci, nodes, minRad, maxRad, collapsed) {
		const bounds = { x: [0, 0], y: [0, 0], maxCi: ci };
		if(!nodes.length) { return bounds; }
		const parentCollapsed = collapsed.indexOf(1 * (nodes[0].parent || {}).systemID) >= 0;
		const max_nodes_per_rad = 1.4;
		if(ci > 0 && !parentCollapsed) {
			var skipped = 0;
			while(++skipped < 2 && nodes.length > max_nodes_per_rad * ci * (maxRad - minRad)) { ci++; }
		}
		const totalArc = parentCollapsed ? nodes.length : nodes.reduce(function(acc, x) { return acc + x.minArc; }, 0);
		const rads_per_arc = (maxRad - minRad) / totalArc;
		var rad_offset = minRad;
		var alignment_delta = 0;
		
		for(var ni = 0; ni < nodes.length; ni++) {
			const node = nodes[ni];	
			
			// Make the node
			const frag = document.createRange().createContextualFragment('<div class="node-wrapper">' + node.markup + '</div>');
			node.domNode = frag.firstChild;
			innerContainer.appendChild(node.domNode);
			const systemID = 1 * node.systemID;
			$(node.domNode).dblclick(() => _this.collapse(systemID, collapsed.indexOf(systemID) < 0));
			
			// Position the node
			const dr = (parentCollapsed ? 1 : node.minArc) * rads_per_arc;
			const rad_centre = rad_offset + (dr / 2);
			
			if(ci == 1 && ni == 0) { // First node on first ring should be axis aligned
				alignment_delta -= rad_centre;
			}
			
			node.radPosition = { r: ci, theta: rad_centre + alignment_delta };
			node.position = radToCartesian(node.radPosition);
			
			if(node.position.x < bounds.x[0]) { bounds.x[0] = node.position.x; }
			if(node.position.x > bounds.x[1]) { bounds.x[1] = node.position.x; }
			if(node.position.y < bounds.y[0]) { bounds.y[0] = node.position.y; }
			if(node.position.y > bounds.y[1]) { bounds.y[1] = node.position.y; }
			
			node.domNode.style.left = node.position.x + 'px';
			node.domNode.style.top = node.position.y + 'px';
			
			if(parentCollapsed) {
				node.domNode.style.display = 'none';
			} else {				
				// Do the segment of the next circle
				const excess = (ci > 0 && dr > node.minArc * ci) ? dr - node.minArc * ci : 0;
				if(node.children.length) {
					const nextBounds = makeDivsForRing(innerContainer, ci + 1, node.children, rad_offset + (0.5 * excess) + alignment_delta, rad_offset - (0.5 * excess) + alignment_delta + dr, collapsed);
					if(nextBounds.x[0] < bounds.x[0]) { bounds.x[0] = nextBounds.x[0]; }
					if(nextBounds.x[1] > bounds.x[1]) { bounds.x[1] = nextBounds.x[1]; }
					if(nextBounds.y[0] < bounds.y[0]) { bounds.y[0] = nextBounds.y[0]; }
					if(nextBounds.y[1] > bounds.y[1]) { bounds.y[1] = nextBounds.y[1]; }
					if(nextBounds.maxCi > bounds.maxCi) { bounds.maxCi = nextBounds.maxCi; }
				}
			}
			rad_offset += dr;
		}
		
		return bounds;
	}

	function radToCartesian(rad) {
		return { 
			x: CIRCLE_SIZE.ringX(rad.r) * Math.sin(rad.theta), 
			y: CIRCLE_SIZE.ringY(rad.r) * Math.cos(rad.theta)
		};

	}

	/** https://stackoverflow.com/questions/40978050 */
	function propertyFromCssClass(className, property) {
		if(Array.isArray(className)) { className = className.join(' '); }
		var elem = document.getElementById('temp-div-' + className);
		if(!elem) {
		  elem = document.createElement("div");
		  elem.id = 'temp-div-' + className;
		  elem.style.cssText = "position:fixed;left:-100px;top:-100px;width:1px;height:1px";
		  elem.className = className + ' temp';
		  document.body.appendChild(elem);  // required in some browsers
		  }
	  const color = getComputedStyle(elem).getPropertyValue(property);
	  //document.body.removeChild(tmp);
	  return color;
	}	
};
var chain = new function() {
	var chain = this;
	this.map, this.view, this.drawing, this.data = {};
	
	thirdPartySuppliers = [ thera ];

	// Renderer should have:
	//  ready() - Whether the renderer is initialised and can accept draw calls
	// switchTo() - Make this renderer active. The renderer can be in a blank state; draw() will be called after
	// switchFrom() - Switch away from this renderer. All node divs should be removed from the DOM, other items can be removed or made invisible
	// draw(map, lines, collapsedSystems) - Redraw the map, based on the given node set, line overrides and list of collapsed systems 
	// collapse(systemID, toggle) - marks the system as collapsed/not collapsed
	// If the renderer allows collapsing of nodes then it will call updateCollapsed on the owner (the chain) with a list of collapsed systems in the current tab
	
	const renderers = { 
		orgChart: new ChainMapRendererOrgchart(this),
		radial: new ChainMapRendererRadial(this)
	};
	
	this.renderer = renderers[options.chain.renderer];
	this.renderer.switchTo();
	
	this.useRenderer = function(name) {
		if(!renderers[name]) { throw 'Unknown renderer ' + name; }
		if(this.renderer != renderers[name]) {
			this.renderer.switchFrom();
			this.renderer = renderers[name];
			this.renderer.switchTo();
			this.redraw();
		}
	}

	this.activity = function(data) {
		/*	function for adding recent activity to chain map nodes	*/
		//var data = typeof(data) !== "undefined" ? data : this.data.activity;

		// Hide all activity colored dots instead of checking each one
		var elements = document.querySelectorAll("#chainMap .nodeActivity span");
		for (var i = 0, l = elements.length; i < l; ++i) {
		   elements[i].className = elements[i].className + " invisible";
		}

		// Loop through passed data and show dots by system
		var elements = document.querySelectorAll("#chainMap [data-nodeid]");
		for (var i = 0, l = elements.length; i < l; ++i) {
		   var systemID = elements[i].getAttribute("data-nodeid");
		   if (data[systemID]) {
			   var shipJumps = data[systemID].shipJumps;
			   var podKills = data[systemID].podKills;
			   var shipKills = data[systemID].shipKills;
			   var npcKills = data[systemID].npcKills;
			   var node = elements[i].getElementsByClassName("nodeActivity")[0];

			   if (shipJumps > 0) {
				   var jumps = node.getElementsByClassName("jumps")[0];
				   jumps.className = jumps.className.replace(/invisible/g, "");
				   jumps.setAttribute("data-tooltip", shipJumps + " Jumps");
			   }

			   if (podKills > 0) {
				   var pods = node.getElementsByClassName("pods")[0];
				   pods.className = pods.className.replace(/invisible/g, "");
				   pods.setAttribute("data-tooltip", podKills + " Pod Kills");
			   }

			   if (shipKills > 0) {
				   var ships = node.getElementsByClassName("ships")[0];
				   ships.className = ships.className.replace(/invisible/g, "");
				   ships.setAttribute("data-tooltip", shipKills + " Ship Kills");
			   }

			   if (npcKills > 0) {
				   var npcs = node.getElementsByClassName("npcs")[0];
				   npcs.className = npcs.className.replace(/invisible/g, "");
				   npcs.setAttribute("data-tooltip", npcKills + " NPC Kills");
			   }
		   }
		}

		if (SystemActivityToolTips.attachedElements && SystemActivityToolTips.attachedElements.length > 0) {
			SystemActivityToolTips.detach($("#chainMap .whEffect"));
		}
		SystemActivityToolTips.attach($("#chainMap .nodeActivity > span[data-tooltip]:not(.invisible)"));

		return data;
	}

	this.occupied = function(data) {
		/*	function for showing occupied icon  */

		// Hide all icons instead of checking each one
		$("#chainMap [data-icon='user'], #chainMap [data-icon='user'] + .badge").addClass("invisible");

		// Loop through passed data and show icons
		for (var x in data) {
			$("#chainMap [data-nodeid='"+data[x].systemID+"'] [data-icon='user']").removeClass("invisible");
			$("#chainMap [data-nodeid='"+data[x].systemID+"'] [data-icon='user'] + .badge").removeClass("invisible").html(data[x].count);
		}

		OccupiedToolTips.attach($("#chainMap [data-icon='user']:not(.invisible)"));

		return data;
	}

	this.flares = function(data) {
		/*	function for coloring chain map nodes via flares  */
		//var data = typeof(data) !== "undefined" ? data : this.data.flares;

		// Remove all current node coloring instead of checking each one
		$("#chainMap div.node").removeClass("redNode yellowNode greenNode");

		// Remove all coloring from chain grid
		$("#chainGrid tr").removeClass("red yellow green");

		// Loop through passed data and add classes by system
		if (data) {
			for (var x in data.flares) {
				var systemID = data.flares[x].systemID;
				var flare = data.flares[x].flare;

				var row = ($("#chainMap [data-nodeid="+systemID+"]").addClass(flare+"Node").parent().index() - 1) / 3 * 2;

				if (row > 0) {
					$("#chainGrid tr:eq("+row+")").addClass(flare).next().addClass(flare);
				}
			}
		}

		return data;
	}

	this.grid = function() {
		/*  function for showing/hiding grid lines  */
		// This is an optional feature
		if (options.chain.gridlines == false) {
			$("#chainGrid tr").addClass("hidden");
			return false;
		}

		$("#chainGrid tr").removeClass("hidden");
		//$("#chainGrid").css("width", "100%");

		// Calculate how many rows have systems, max 0 hack to prevent negative numbers, and rows above this number get hidden
		var rows = Math.max(0, $(".google-visualization-orgchart-table tr:has(.node)").length * 2 - 1);
		$("#chainGrid tr:gt("+rows+")").addClass("hidden");
	}

	this.nodes = function(map) {
		var chain = {cols: [{label: "System", type: "string"}, {label: "Parent", type: "string"}], rows: []};
		var frigTypes = ["Q003", "E004", "L005", "Z006", "M001", "C008", "G008", "A009", "SML" ];
		var connections = [];
		var chainMap = this;

		function formatStatics(statics) {
			if(!statics) { return ''; }
			const shortCodeMap = { 'High-Sec': 'H', 'Low-Sec': 'L', 'Null-Sec': 'N', 'Triglavian':'',
				'Class 1': '1', 'Class 2': '2', 'Class 3': '3', 'Class 4': '4', 'Class 5' : 5, 'Class 6': 6
			};
			const classMap = { H: 'hisec', L: 'lowsec', N: 'nullsec', '': 'triglavian' };
			return statics.map(function(s) {
				const text = shortCodeMap[tripwire.wormholes[s].leadsTo];
				const className = classMap[text] || 'class-' +  text;
				const tip = tripwire.wormholes[s].leadsTo + ' via ' + s;
				return '<span class="' + className + '" data-tooltip="' + tip + '">' + text + '</span>';
			}).join('');
		}

		function topLevel(systemID, id) {
			if (!systemID || !tripwire.systems[systemID])
				return false;
			const tab = options.chain.tabs[options.chain.active];
			const tabName = tab && tab.systemID != 0 && 0 > tab.systemID.indexOf(',') ? options.chain.tabs[options.chain.active].name : undefined;
			return makeSystemNode(systemID, id, null, null, tabName, '&nbsp;', ['top-level']);
		}

		function makeSystemNode(systemID, id, whId, inSigId, systemName, nodeTypeMarkup, additionalClasses) {
			// System type switch
			var systemType = getSystemType(systemID);
			const system = tripwire.systems[systemID];

			var effectClass = null, effect = null;
			if (system && system.effect) {
				switch(system.effect) {
					case "Black Hole":
						effectClass = "blackhole";
						break;
					case "Cataclysmic Variable":
						effectClass = "cataclysmic-variable";
						break;
					case "Magnetar":
						effectClass = "magnetar";
						break;
					case "Pulsar":
						effectClass = "pulsar";
						break;
					case "Red Giant":
						effectClass = "red-giant";
						break;
					case "Wolf-Rayet Star":
						effectClass = "wolf-rayet";
						break;
				}

				effect = system.effect;
			}
			
			systemName = _.escape(systemName);
			const systemNameText = 
				options.chain.sigNameLocation == 'name' ? (systemName ? systemName : system ? system.name : '&nbsp;') :
				options.chain.sigNameLocation == 'name_prefix' ?
					(systemName ? systemName + (system ? ' - ' + system.name : '') : (system ? system.name : '&nbsp;')) :
				(system ? system.name : '&nbsp;');	

			var node = {v: id, systemID: systemID };
			var chainNode = "<div id='node"+id+"' data-nodeid='"+systemID+"'"
				+(whId ? " data-sigid='"+whId+"'" : '')
				+(inSigId ? " data-inSigid='"+inSigId+"'" : '')
				+" class='node " + ((additionalClasses || []).join(' ')) + "'>"
							+	"<div class='nodeIcons'>"
							+		"<div style='float: left;'>"
							+			"<i class='whEffect' "+(effectClass ? "data-icon='"+effectClass+"' data-tooltip='"+effect+"'" : null)+"></i>"
							+		"</div>"
							+		"<div style='float: right;'>"
							+			"<i data-icon='user' class='invisible'></i>"
							+			"<span class='badge invisible'></span>"
							+		"</div>"
							+	"</div>"
							+	"<h4 class='nodeClass'>"+systemType+"</h4>"
							+	"<h4 class='nodeSystem'>"
							+		(system ? "<a href='.?system="+system.name+"'>"+systemNameText+"</a>" : systemNameText)
							+	"</h4>"
							+	"<h4 class='nodeType'>" + nodeTypeMarkup + "</h4>"
							+	"<div class='statics'>"
							+ formatStatics(system ? system.statics : [])
							+	"</div>"
							+	"<div class='nodeActivity'>"
							+		"<span class='jumps invisible'>&#9679;</span>&nbsp;<span class='pods invisible'>&#9679;</span>&nbsp;&nbsp;<span class='ships invisible'>&#9679;</span>&nbsp;<span class='npcs invisible'>&#9679;</span>"
							+	"</div>"
							+"</div>";

			node.f = chainNode;

			return node;
		}
		
		function makeCalcChildNode(childID, node, targetSystem) {
			var path = guidance.findShortestPath(tripwire.map.shortest, [targetSystem - 30000000, node.child.systemID - 30000000]);
			if(!path) { return null; }
			
			var calcNode = { calculated: true};
			calcNode.life = "Gate";
			calcNode.parent = {};
			calcNode.parent.id = node.child.id;
			calcNode.parent.systemID = node.child.systemID;
			calcNode.parent.name = node.child.name;
			calcNode.parent.type = node.child.type;
			calcNode.parent.nth = node.child.nth;

			calcNode.child = {};
			calcNode.child.id = ++childID;
			calcNode.child.systemID = targetSystem;
			calcNode.child.name = tripwire.systems[targetSystem].name;
			calcNode.child.path = path;
			calcNode.child.jumps = path.length - 1;
			calcNode.child.nth = null;			
			
			return { childID, calcNode };
		}
		
		function getSystemType(systemID) {
			var system = systemAnalysis.analyse(systemID);
			if(!system) { 
				var leadsToPointer = typeof(systemID) === "string" && systemID.indexOf("|") >= 0 ? tripwire.aSigSystems[systemID.substring(0, systemID.indexOf("|"))] : null;
				const nodeClass = 
					leadsToPointer && leadsToPointer.substring(0, 6) == 'Class-' ? 1 * leadsToPointer.substring(6) :
					undefined;
				const nodeSecurity = 
					leadsToPointer == "High-Sec" ? 0.8 :
					leadsToPointer == "Low-Sec" ? 0.4 :
					leadsToPointer == "Null-Sec" ? -0.1 :
					undefined;
				const nodeFaction = 
					leadsToPointer == "Triglavian" ? 500026 :
					undefined;
				
				system = systemAnalysis.analyse(systemID, { security: nodeSecurity, class: nodeClass, factionID: nodeFaction } );
			}
			return "<span class='" + system.systemTypeClass + "'>" + system.systemTypeName + system.systemTypeModifiers.join('') + "</span>";
		}		

		function findLinks(system) {
			if (system[0] <= 0) return false;

			var parentID = parseInt(system[1]), childID = chainList.length;
			const connectedTo = [];	// Local cache, in addition to usedLinks, for extra link sources

			/** Add the 'current' and 'favourite' calculated nodes if appropriate */
			const addCalcChildNodes = function(node) {
				if ($("#show-viewing").hasClass("active") && tripwire.systems[node.child.systemID] && !tripwire.systems[viewingSystemID].class && !tripwire.systems[node.child.systemID].class && viewingSystemID != node.child.systemID ) {
					var calcNode = makeCalcChildNode(childID, node, viewingSystemID);
					if(calcNode) {
						childID = calcNode.childID;

						chainLinks.push(calcNode.calcNode);
						chainList.push([0, childID]);
					}
				}

				if ($("#show-favorite").hasClass("active") && tripwire.systems[node.child.systemID] && !tripwire.systems[node.child.systemID].class) {
					for (var x in options.favorites) {
						if (tripwire.systems[options.favorites[x]].regionID >= 11000000 || tripwire.systems[node.child.systemID].regionID >= 11000000 || options.favorites[x] == node.child.systemID)
							continue;

						var calcNode = makeCalcChildNode(childID, node, options.favorites[x]);
						if(calcNode) {
							childID = calcNode.childID;

							chainLinks.push(calcNode.calcNode);
							chainList.push([0, childID]);
						}
					}
				}				
			};

			for (var x in chainData) {
				var wormhole = chainData[x];				
				if ($.inArray(wormhole.id, usedLinks) == -1) {
					var sig1, sig2, sig1Type, sig2Type,
						parent, child, parentType, childType;
					if (wormhole.parent == "secondary") {
						sig1 = tripwire.client.signatures[wormhole.secondaryID];
						sig2 = tripwire.client.signatures[wormhole.initialID];
					} else {
						sig1 = tripwire.client.signatures[wormhole.initialID];
						sig2 = tripwire.client.signatures[wormhole.secondaryID];
					}
					sig1Type = wormhole.type; sig2Type = 'K162';
					
					if (sig1 && sig1.systemID == system[0]) {
						parent = sig1; child = sig2;
						parentType = sig2Type; childType = sig1Type;
					} else if(sig2 && sig2.systemID == system[0]) {
						parent = sig2; child = sig1;
						childType = sig2Type; parentType = sig1Type;
					} else { continue; }
					
					var node = {};
					node.id = wormhole.id;
					node.life = wormhole.life;
					node.mass = wormhole.mass;
					node.time = parent.modifiedTime;

					node.parent = {};
					node.parent.id = parentID;
					node.parent.systemID = tripwire.systems[parent.systemID] ? parent.systemID : parent.systemID + "|" + Math.floor(Math.random() * Math.floor(10000));
					node.parent.name = parent.name;
					node.parent.type = parentType;
					node.parent.typeBM = null;
					node.parent.classBM = null;
					node.parent.nth = null;
					node.parent.signatureID = child.signatureID;
					node.parent.sigIndex = child.id;

					node.child = {};
					node.child.id = ++childID;
					node.child.systemID = tripwire.systems[child.systemID] ? child.systemID : child.systemID + "|" + Math.floor(Math.random() * Math.floor(10000));
					node.child.name = child.name;
					node.child.type = childType;
					node.child.typeBM = null;
					node.child.classBM = null;
					node.child.nth = null;
					node.child.signatureID = parent.signatureID;
					node.child.sigIndex = parent.id;

					chainLinks.push(node);
					chainList.push([node.child.systemID, node.child.id, system[2]]);
					usedLinks.push(node.id);
					if(tripwire.systems[child.systemID]) { connectedTo.push(1 * child.systemID); }	// cast to number - sigs have the system as a string
					// usedLinks[system[2]].push(node.id);
					
					addCalcChildNodes(node);					
				}
			}
			
			thirdPartySuppliers.forEach(function(supplier) {				
				const ids = { parentID: parentID, nextChildID: ++childID };
				const supplierNodes = supplier.findLinks(1 * system[0], ids);
				if(!supplierNodes) { return; }
				childID = ids.nextChildID - 1;

				for(var ti = 0; ti < supplierNodes.length; ti++) {
					var supplierNode = supplierNodes[ti];
					if(0 > usedLinks.indexOf(supplierNode.id)) {
						if(0 > connectedTo.indexOf(supplierNode.child.systemID)) { // not in our map already
							supplierNode.thirdParty = supplier.nodeNameSuffix;
								
							chainLinks.push(supplierNode);
							chainList.push([supplierNode.child.systemID, supplierNode.child.id, system[2]]);
							connectedTo.push(supplierNode.child.systemID);		
							
							addCalcChildNodes(supplierNode);		
						}							
						// Always want to do this, even if we didn't add it, because in that case the link is overridden by one on this mask, so it is 'used' even if not made visible
						usedLinks.push(supplierNode.id);	
					}
				}
			});
		}
		
		if ($("#chainTabs .current").length > 0) {
			var systems = $("#chainTabs .current .name").data("tab").toString().split(",");
			var chainList = [];
			var chainData = map;
			var chainLinks = [];
			var usedLinks = [];

			if (systems == 0) {
                                let i = 0;
                                Object.keys(map).slice()/*.reverse()*/.forEach(x => {
				        const parent = tripwire.client.signatures[map[x].initialID];
				        const child = tripwire.client.signatures[map[x].secondaryID];
                                        if (parent && tripwire.systems[parent.systemID] && typeof(tripwire.systems[parent.systemID].class) == "undefined") {
						i++;
						// usedLinks[parent.systemID] = [];
						chain.rows.push({c: [topLevel(parent.systemID, i), {v: null}]});
						chainList.push([parent.systemID, i, parent.systemID]);
                                        } else if (child && tripwire.systems[child.systemID] && typeof(tripwire.systems[child.systemID].class) == "undefined") {
				  	        i++;
				  		// usedLinks[child.systemID] = [];
						chain.rows.push({c: [topLevel(child.systemID, i), {v: null}]});
						chainList.push([child.systemID, i, child.systemID]);
					}
				});
			} else {
				for (var x in systems) {
					// usedLinks[systems[x]] = [];
					chain.rows.push({c: [topLevel(systems[x], parseInt(x) + 1), {v: null}]});
					chainList.push([systems[x], parseInt(x) + 1, systems[x]]);
				}
			}

			for (var i = 0; i < chainList.length; i++) {
				findLinks(chainList[i]);
			}
		} else {
			$("#chainError").hide();

			var row = {c: []};
			var systemID = viewingSystemID;

			row.c.push(topLevel(systemID, 1), {v: null});

			chain.rows.push(row);

			var chainList = [[systemID, 1]];
			var chainData = map;
			var chainLinks = [];
			var usedLinks = [];

			for (var i = 0; i < chainList.length; ++i) {
				findLinks(chainList[i]);
			}
		}

		const systemsInChainMap = {};
		for (var x in chainLinks) {
			var node = chainLinks[x];
			var row = {c: []};
			
			const sigText = options.chain["node-reference"] == "id" ? (node.child.signatureID ? node.child.signatureID.substring(0, 3) : "???") :
					(node.child.type || "(?)") + sigFormat(node.child.typeBM, "type");
			const nodeTypeMarkup = node.child.path ? 
				chainMap.renderPath(node.child.path) :
				"<a href='#' onclick='openSignatureDialog({data: { signature: " + node.child.sigIndex + ", mode: \"update\" }}); return false;'>" + _.escape(
					node.parent.name && options.chain.sigNameLocation == 'ref' ? node.parent.name :
					node.parent.name && options.chain.sigNameLocation == 'ref_prefix' ? node.parent.name + ' - ' + sigText :
					sigText
				) + '</a>';
			const additionalClasses = node.calculated ? ['calc'] : systemsInChainMap[node.child.systemID] ? [ 'loop' ] : [];
			if(node.thirdParty) { additionalClasses.push('third-party', 'third-party-' + node.thirdParty); }
			const child = makeSystemNode(node.child.systemID, node.child.id, node.id, node.child.sigIndex, node.parent.name, nodeTypeMarkup, additionalClasses);

			var parent = {v: node.parent.id};

			row.c.push(child, parent);
			chain.rows.push(row);
			
			var modifiers = [];			
			if (node.life == "critical") { modifiers.push('eol'); }
			if (node.mass == "critical") { modifiers.push('critical'); }
			else if (node.mass == "destab") { modifiers.push('destab'); }
			
			if($.inArray(node.parent.type, frigTypes) != -1 || $.inArray(node.child.type, frigTypes) != -1) { modifiers.push('frig'); }
			
			if(modifiers.length) { connections.push(Array(child.v, parent.v, modifiers, node.id)); }
			
			if(!node.calculated) { systemsInChainMap[node.child.systemID] = row; }	// store for loops
		}

		// Apply critical/destab line colors
		connections.reverse(); // so we apply to outer systems first

		//this.data.map = chain;
		//this.data.lines = connections;
		return {"map": chain, "lines": connections};
	}

	this.renderPath = function(path) {
		if(path.length <= 1 || path.length > options.chain.routingLimit) { return '' + path.length - 1; }
		else {
			var systemMarkup = path
			.slice(0, path.length - 1).reverse()
			.map(function(s) {
				const systemID = 30000000 + 1 * s;
				const system = systemAnalysis.analyse(systemID);
				const securityClass = system.systemTypeClass;
				return '<span class="' + securityClass + '" data-tooltip="' + system.name + ' (' + system.security + ')" onclick="tripwire.systemChange(' + systemID + ')">' + system.pathSymbol + '</span>';
			});
			var r = '<span class="path">';
			for(var i = 0; i < systemMarkup.length; i++) {
				if(i > 0 && 0 == i % 5) { r += '|'; }
				
				r += systemMarkup[i];				 
			}
			return r + '</span>';
		}
	}

	this.setActiveTab = function(newIndex) {
		$("#chainTabs .tab").removeClass("current");
		options.chain.active = newIndex;
		if(newIndex != null) {
			$("#chainTabs .tab").eq(newIndex).addClass('current');
		}
		
		options.save();
		chain.redraw();
		tripwire.parse(tripwire.client, "refresh");
	}

	this.redraw = function() {
		this.useRenderer(options.chain.renderer);
		
		var data = $.extend(true, {}, this.data);
		data.map = $.extend(true, {}, data.rawMap);

		this.draw(data);
	}
	
	var drawRetryTimer = null;

	this.draw = function(data) {
		var data = typeof(data) !== "undefined" ? data : {};
		clearTimeout(drawRetryTimer);

		// We need to make sure Google chart is ready and we have signature data for this system before we begin, otherwise delay
		if (!this.renderer.ready() || (Object.size(data.map) && !tripwire.client.signatures)) {
			drawRetryTimer = setTimeout(function() { chain.draw(data) }, 100);
			return;
		}

		if (data.map) {
			this.drawing = true;

			this.data.rawMap = $.extend(true, {}, data.map);

			// if (options.chain.active == null || (options.chain.tabs[options.chain.active] && options.chain.tabs[options.chain.active].evescout == false)) {
			// 	if (options.masks.active != "273.0") {
			// 		for (var i in data.map) {
			// 			if (data.map[i].mask == "273.0") {
			// 				delete data.map[i];
			// 			}
			// 		}
			// 	}
			// }

			// Sort so we keep the chain map order the same
			Object.sort(data.map, "id");

			$.extend(data, this.nodes(data.map)); // 250ms -> <100ms
			$.extend(this.data, data);
			
			const collapsedSystems = options.chain.tabs[options.chain.active] ? (options.chain.tabs[options.chain.active].collapsed || []) : [];

			this.renderer.draw(data.map, data.lines, collapsedSystems); // 150ms
			//this.map.draw(this.newView(data.map), this.options); // 150ms

//			this.renderer.lines(data); // 300ms
			this.grid(); // 4ms

			// Apply current system style
			$("#chainMap [data-nodeid='"+viewingSystemID+"']").parent().addClass("currentNode"); // 0.1ms

			// Remove old system effect tooltips and add current ones
			if (WormholeTypeToolTips.attachedElements && WormholeTypeToolTips.attachedElements.length > 0) {
				WormholeTypeToolTips.detach($("#chainMap .whEffect"));
			}
			WormholeTypeToolTips.attach($("#chainMap .whEffect[data-icon]")); // 0.30ms
			WormholeRouteToolTips.attach($("#chainMap .path span[data-tooltip]"));
			SystemActivityToolTips.attach($("#chainMap .nodeClass span[data-tooltip]"));

			this.drawing = false;
		}

		// Gather latest system activity
		if (!this.data.activity || new Date() > this.data.activity.expires) {
			data.activity = {};
			tripwire.esi.universeJumps()
				.done(function(results, status, request) {
					data.activity.expires = new Date(request.getResponseHeader("expires"));
					$.each(results, function(x) {
						data.activity[results[x].system_id] = {
							systemID: results[x].system_id,
							shipJumps: results[x].ship_jumps
						}
					});
				})
				.then(function() {
					 return tripwire.esi.universeKills()
						.done(function(results) {
							$.each(results, function(x) {
								if (data.activity[results[x].system_id]) {
									data.activity[results[x].system_id].podKills = results[x].pod_kills;
									data.activity[results[x].system_id].shipKills = results[x].ship_kills;
									data.activity[results[x].system_id].npcKills = results[x].npc_kills;
								} else {
									data.activity[results[x].system_id] = {
										systemID: results[x].system_id,
										podKills: results[x].pod_kills,
										shipKills: results[x].ship_kills,
										npcKills: results[x].npc_kills,
									}
								}
							});
						});
				})
				.then(function() {
					chain.data.activity = chain.activity(data.activity);
				});
		} else if (data.map) {
			chain.activity(this.data.activity);
		}

		if (data.occupied) { // 3ms
			this.data.occupied = this.occupied(data.occupied);
		}

		if (data.flares) { // 20ms
			this.data.flares = this.flares(data.flares);
		}
	}

	this.updateCollapsed = function(collapsedSystems) {
		if (options.chain.tabs[options.chain.active]) {
			options.chain.tabs[options.chain.active].collapsed = collapsedSystems;
		}
		
		// Apply current system style
		$("#chainMap [data-nodeid='"+viewingSystemID+"']").parent().addClass("currentNode");

		if (WormholeTypeToolTips.attachedElements && WormholeTypeToolTips.attachedElements.length > 0) {
			WormholeTypeToolTips.detach($("#chainMap .whEffect"));
		}
		WormholeTypeToolTips.attach($("#chainMap .whEffect[data-icon]"));

		chain.activity(chain.data.activity);

		chain.occupied(chain.data.occupied);

		chain.flares(chain.data.flares);

		chain.grid();

		options.save();
	}

}

tripwire.active = function(data) {
    var editSigs = [];
    var editComments = [];

    for (var x in data) {
        var activity = JSON.parse(data[x].activity);
        editSigs.push(parseInt(activity.editSig));
        editComments.push(parseInt(activity.editComment));

        if (activity.editSig) {
            $("#sigTable tr[data-id='"+activity.editSig+"']")
                //.attr('data-tooltip', sig.editing)
                //.attr("title", sig.editing)
                .addClass("editing")
                .find("td")
                .animate({backgroundColor: "#001b47"}, 1000); //35240A - Yellow
        }

        if (activity.editComment && $("#commentWrapper .comment[data-id='"+activity.editComment+"'] .cke").length > 0) {
            $("#commentWrapper .comment[data-id='"+activity.editComment+"']")
                .addClass("editing")
                .find(".commentStatus").html(data[x].characterName + " is editing").fadeIn();
        }
    }

    $("#sigTable tr.editing").each(function() {
        if ($.inArray($(this).data("id"), editSigs) == -1) {
            $("#sigTable tr[data-id='"+$(this).data("id")+"']")
                //.attr('data-tooltip', '')
                //.removeAttr("title")
                .removeClass("editing")
                .find("td")
                .animate({backgroundColor: "#111"}, 1000, null, function() {$(this).css({backgroundColor: ""});});
        }
    });

    $("#commentWrapper .editing").each(function() {
        if ($.inArray($(this).data("id"), editComments) == -1) {
            $("#commentWrapper .editing[data-id='"+$(this).data("id")+"']")
                .removeClass("editing")
                .find(".commentStatus").fadeOut(function() {$(this).html("")});
        }
    });
}

// Hanldes adding to Signatures section
// ToDo: Use native JS
tripwire.addSig = function(add, option, disabled) {
    var option = option || {};
    var animate = typeof(option.animate) !== 'undefined' ? option.animate : true;
    var disabled = disabled || false;
    var wormhole = {};

    if (add.type == "wormhole") {
        var wormhole = Object.values(tripwire.client.wormholes).find(function (wh) { return wh.initialID == add.id || wh.secondaryID == add.id});
        if (!wormhole) return false;
        var otherSignature = add.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID];
        if (!otherSignature) return false;

        if (add.name) {
          leadsTo = tripwire.systems[otherSignature.systemID] ? "<a href='.?system="+tripwire.systems[otherSignature.systemID].name+"'>"+add.name+"</a>" : add.name;
        } else if (tripwire.aSigSystems[otherSignature.systemID]) {
            leadsTo = tripwire.aSigSystems[otherSignature.systemID];
        } else if (tripwire.systems[otherSignature.systemID]) {
            leadsTo = "<a href='.?system="+tripwire.systems[otherSignature.systemID].name+"'>"+tripwire.systems[otherSignature.systemID].name+"</a>";
        } else {
            leadsTo = "";
        }

        var row = "<tr data-id='"+add.id+"' data-tooltip='' "+ (disabled ? 'disabled="disabled"' : '') +">"
            + "<td class='"+ options.signatures.alignment.sigID +"'>"+(add.signatureID ? add.signatureID.substring(0, 3)+"-"+(add.signatureID.substring(3, 6) || "###") : "???-###")+"</td>"
            + "<td class='type-tooltip "+ options.signatures.alignment.sigType +"' data-tooltip=\""+this.whTooltip(wormhole)+"\">"+(wormhole[wormhole.parent+"ID"] == add.id ? wormhole.type || "" : (wormhole.parent ? "K162" : ""))+"</td>"
            + "<td class='age-tooltip "+ options.signatures.alignment.sigAge + (parseInt(add.lifeLength) === 0 ? " disabled" : "") +"' data-tooltip='"+this.ageTooltip(add)+"'><span data-age='"+add.lifeTime+"'></span></td>"
            + "<td class='"+ options.signatures.alignment.leadsTo +"'>"+(leadsTo || "")+"</td>"
            + "<td class='"+wormhole.life+" "+ options.signatures.alignment.sigLife +"'>"+wormhole.life+"</td>"
            + "<td class='"+wormhole.mass+" "+ options.signatures.alignment.sigMass +"'>"+wormhole.mass+"</td>"
            + "</tr>";

        var tr = $(row);
    } else {
        var row = "<tr data-id='"+add.id+"' data-tooltip='' "+ (disabled ? 'disabled="disabled"' : '') +">"
            + "<td class='"+ options.signatures.alignment.sigID +"'>"+(add.signatureID ? add.signatureID.substring(0, 3)+"-"+(add.signatureID.substring(3, 6) || "###") : "???-###")+"</td>"
            + "<td class='"+ options.signatures.alignment.sigType +"'>"+add.type+"</td>"
            + "<td class='age-tooltip "+ options.signatures.alignment.sigAge + (parseInt(add.lifeLength) === 0 ? " disabled" : "") +"' data-tooltip='"+this.ageTooltip(add)+"'><span data-age='"+add.lifeTime+"'></span></td>"
            + "<td class='"+ options.signatures.alignment.leadsTo +"' colspan='3'>"+(add.name?linkSig(add.name):'')+"</td>"
            + "</tr>";

        var tr = $(row);
    }

    Tooltips.attach($(tr).find("[data-tooltip]"));

    $("#sigTable").append(tr);

    // Add counter
    if (wormhole.life == "critical") {
        $(tr).find('span[data-age]').countdown({until: moment.utc(add.lifeLeft).toDate(), onExpiry: this.pastEOL, alwaysExpire: true, compact: true, format: this.ageFormat, serverSync: this.serverTime.getTime})
            // .countdown('pause')
            .addClass('critical')
            // .countdown('resume');
    } else {
        $(tr).find('span[data-age]').countdown({since: moment.utc(add.lifeTime).toDate(), compact: true, format: this.ageFormat, serverSync: this.serverTime.getTime});
    }

    if (animate) {
        $(tr)
            .find('td')
            .wrapInner('<div class="hidden" />')
            .parent()
            .find('td > div')
            .slideDown(700, function(){
                $set = $(this);
                $set.replaceWith($set.contents());
            });

        $(tr).find("td").animate({backgroundColor: "#004D16"}, 1000).delay(1000).animate({backgroundColor: "#111"}, 1000, null, function() {$(this).css({backgroundColor: ""});});
    }
}

// Handles API updates
tripwire.API = function() {
    this.indicator;
    this.APIrefresh;

    this.API.expire = function() {
        var options = {since: tripwire.API.APIrefresh, until: null, format: "MS", layout: "-{mnn}{sep}{snn}"};
        $("#APItimer").countdown("option", options);
    }

    this.API.refresh = function() {
        $.ajax({
            url: "api_update.php",
            cache: false,
            dataType: "JSON",
            data: "indicator="+tripwire.API.indicator
        }).done(function(data) {
            if (data && data.APIrefresh) {
                tripwire.API.indicator = data.indicator;
                tripwire.API.APIrefresh = new Date(data.APIrefresh);
                activity.refresh(); //Refresh graph

                var options = {until: tripwire.API.APIrefresh, since: null, layout: "{mnn}{sep}{snn}"};
                $("#APItimer").countdown("option", options);
                setTimeout("tripwire.API.refresh();", $.countdown.periodsToSeconds($("#APItimer").countdown('getTimes')) - 30);
            } else if ($("#APItimer").countdown("option", "layout") !== "-{mnn}{sep}{snn}" && $.countdown.periodsToSeconds($("#APItimer").countdown('getTimes')) > 120) {
                setTimeout("tripwire.API.refresh();", ($.countdown.periodsToSeconds($("#APItimer").countdown('getTimes')) - 30) * 1000);
            } else {
                setTimeout("tripwire.API.refresh();", 15000);
            }
        });
    }

    this.API.init = function() {
        $.ajax({
            url: "api_update.php",
            cache: true,
            dataType: "JSON",
            data: "init=true"
        }).done(function(data) {
            tripwire.API.indicator = data.indicator;
            tripwire.API.APIrefresh = new Date(data.APIrefresh);

            $("#APItimer").countdown({until: tripwire.API.APIrefresh, onExpiry: tripwire.API.expire, alwaysExpire: true, compact: true, format: "MS", serverSync: tripwire.serverTime.getTime, onTick: function(t) { $("#APIclock").val(t[5] + 1).trigger("change"); }})
            var timer = $("#APItimer").countdown("option", "layout") === "-{mnn}{sep}{snn}" ? 15 : $.countdown.periodsToSeconds($("#APItimer").countdown('getTimes')) - 30;
            setTimeout("tripwire.API.refresh();", timer * 1000);
        });
    }

    this.API.init();
}
// tripwire.API();

tripwire.autoMapper = function(from, to) {
    var pods = [33328, 670];
    var undo = [];

    // Convert from & to from system name to system ID for diagnostic testing
    // from = viewingSystemID;
    // to = Object.index(tripwire.systems, 'name', to);

    // Make sure the automapper is turned on & not disabled
    if (!$("#toggle-automapper").hasClass("active") || $("#toggle-automapper").hasClass("disabled"))
        return false;

    // Make sure from and to are valid systems
    if (!tripwire.systems[from] || !tripwire.systems[to])
        return false;

    // Make sure from and to are not the same system
    if (from == to)
        return false;

    // Is pilot in a station?
    if (tripwire.client.EVE && tripwire.client.EVE.stationID)
        return false;

    // Is pilot in a pod?
    if (tripwire.client.EVE && tripwire.client.EVE.shipTypeID && $.inArray(parseInt(tripwire.client.EVE.shipTypeID), pods) >= 0)
         return false;

    // Is this a gate?
    if (typeof(tripwire.map.shortest[from - 30000000]) != "undefined" && typeof(tripwire.map.shortest[from - 30000000][to - 30000000]) != "undefined")
        return false;

     // Is this an existing connection?
     if ($.map(tripwire.client.wormholes,
               function(wormhole) {
                 const initial = tripwire.client.signatures[wormhole.initialID];
                 const secondary = tripwire.client.signatures[wormhole.secondaryID];
                 return initial && secondary &&
                   ((initial.systemID == from && secondary.systemID == to) ||
                    (initial.systemID == to && secondary.systemID == from))  ? wormhole : null;
               }).length > 0) {
       return false;
     }

    var payload = {"signatures": {"add": [], "update": []}};
    var sig, toClass;

    if (tripwire.systems[to].class)
        toClass = "Class-" + tripwire.systems[to].class;
    else if (tripwire.systems[to].security >= 0.45)
        toClass = "High-Sec";
    else if (tripwire.systems[to].security > 0)
        toClass = "Low-Sec";
    else
        toClass = "Null-Sec";

    var wormholes = $.map(tripwire.client.wormholes, function(wormhole) {
        if ( ( tripwire.client.signatures[wormhole.initialID] !== undefined ) && ( tripwire.client.signatures[wormhole.secondaryID] !== undefined ) ) {
            // Find wormholes that have no set Leads To system, and their initial system is from the wormhole we just jumped from
            if (tripwire.client.signatures[wormhole.initialID].systemID == from && !tripwire.systems[tripwire.client.signatures[wormhole.secondaryID].systemID]) {
                if (tripwire.aSigSystems[tripwire.client.signatures[wormhole.secondaryID].systemID] == toClass) {
                    // Find wormholes that Leads To is generically set to the class we just jumped into
                    return wormhole;
                } else if (wormhole.type && tripwire.wormholes[wormhole.type] && tripwire.wormholes[wormhole.type].leadsTo.replace(' ', '-') == toClass) {
                    // Find wormholes that Type is known to lead to the class we just jumped into
                    return wormhole;
                } else if (tripwire.client.signatures[wormhole.secondaryID].systemID === null && (!wormhole.type || !tripwire.wormholes[wormhole.type])) {
                    // Find wormholes that don't have a Type or any kind of Leads To entered
                    return wormhole;
                }
            }
        }
    });

    if (wormholes.length) {
        if (wormholes.length > 1) {
            $("#dialog-select-signature").dialog({
                autoOpen: true,
                title: "Which Signature?",
                width: 390,
                buttons: {
                    Cancel: function() {
                        $(this).dialog("close");
                    },
                    Ok: function() {
                        var i = $("#dialog-select-signature [name=sig]:checked").val();
                        var wormhole = wormholes[i];
                        var signature = tripwire.client.signatures[wormhole.initialID];
                        var signature2 = tripwire.client.signatures[wormhole.secondaryID];

                        payload.signatures.update.push({
                            "wormhole": {
                                "id": wormhole.id
                            },
                            "signatures": [
                                {
                                    "id": signature.id
                                },
                                {
                                    "id": signature2.id,
                                    "systemID": to
                                }
                            ]
                        });

                        var success = function(data) {
                            if (data.resultSet && data.resultSet[0].result == true) {
                                undo.push({"wormhole": wormhole, "signatures": [signature, signature2]});
                                $("#dialog-select-signature").dialog("close");
                            }
                        }

                        tripwire.refresh('refresh', payload, success);
                    }
                },
                open: function() {
                    $("#dialog-select-signature .optionsTable tbody").empty();

                    $.each(wormholes, function(i) {
                        var signature = tripwire.client.signatures[wormholes[i].initialID];
                        var signatureRow = $("#sigTable tr[data-id='"+signature.id+"']").html();
                        var tr = "<tr>"
                          + "<td><input type='radio' name='sig' value='"+i+"' id='sig"+i+"' /></td>"
                          + signatureRow
                          + "</tr>";

                        $("#dialog-select-signature .optionsTable tbody").append(tr);
                        $("#dialog-select-signature .optionsTable tbody td").wrapInner("<label for='sig"+i+"' />");
                    });
                }
            });
        } else {
            var wormhole = wormholes[0];
            var signature = tripwire.client.signatures[wormhole.initialID];
            var signature2 = tripwire.client.signatures[wormhole.secondaryID];

            payload.signatures.update.push({
                "wormhole": {
                    "id": wormhole.id
                },
                "signatures": [
                    {
                        "id": signature.id
                    },
                    {
                        "id": signature2.id,
                        "systemID": to
                    }
                ]
            });
            undo.push({"wormhole": wormhole, "signatures": [signature, signature2]});
        }
    } else {
        // Nothing matches, create a new wormhole
        payload.signatures.add.push({
            "wormhole": {
                "type": null,
                "parent": "initial",
                "life": "stable",
                "mass": "stable"
            },
            "signatures": [
                {
                    "systemID": from,
                    "type": "wormhole"
                },
                {
                    "systemID": to,
                    "type": "wormhole"
                }
            ]
        });
    }

    if (payload.signatures.add.length || payload.signatures.update.length) {
        var success = function(data) {
            if (data.resultSet && data.resultSet[0].result == true) {
                $("#undo").removeClass("disabled");

                if (data.results) {
                    if (viewingSystemID in tripwire.signatures.undo) {
                        tripwire.signatures.undo[viewingSystemID].push({action: "add", signatures: data.results});
                    } else {
                        tripwire.signatures.undo[viewingSystemID] = [{action: "add", signatures: data.results}];
                    }
                }

                if (undo.length) {
                    if (viewingSystemID in tripwire.signatures.undo) {
                        tripwire.signatures.undo[viewingSystemID].push({action: "update", signatures: undo});
                    } else {
                        tripwire.signatures.undo[viewingSystemID] = [{action: "update", signatures: undo}];
                    }
                }

                sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
            }
        }

        tripwire.refresh('refresh', payload, success);
    }
}

tripwire.comments = function() {
    this.comments.data = {};

    this.comments.parse = function(data) {
        for (var x in data) {
            var id = data[x].id;

            if (!Object.find(tripwire.comments.data, "id", id) && $(".comment[data-id='"+id+"']").length == 0) {
                var $comment = $(".comment:last").clone();
                var commentID = $(".comment:visible:last .commentBody").attr("id") ? $(".comment:visible:last .commentBody").attr("id").replace("comment", "") + 1 : 0;

                //data[id].sticky ? $(".comment:first").before($comment) : $(".comment:last").before($comment);
                $(".comment:last").before($comment);
                $comment.attr("data-id", id);

                try {
                    $comment.find(".commentBody").html(data[x].comment);
                } catch (err) {
                    $comment.find(".commentFooter").show();
                    $comment.find(".commentStatus").html("<span class='critical'>" + err.constructor.name + ": " + err.message + "</span>");
                    $comment.find(".commentFooter .commentControls").hide();
                }

                $comment.find(".commentModified").html("Edited by " + data[x].modifiedByName + " at " + data[x].modified);
                $comment.find(".commentCreated").html("Posted by " + data[x].createdByName + " at " + data[x].created);
                $comment.find(".commentBody").attr("id", "comment" + commentID);
                $comment.find(".commentSticky").addClass(data[x].sticky ? "active" : "");
                $comment.removeClass("hidden");
                Tooltips.attach($comment.find("[data-tooltip]"));

                //tripwire.comments.data[id] = data[id];
            } else if (Object.find(tripwire.comments.data, "id", id) && Object.find(tripwire.comments.data, "id", id).modified != data[x].modified) {
                var $comment = $(".comment[data-id='"+id+"']");

                try {
                    $comment.find(".commentBody").html(data[x].comment);
                } catch (err) {
                    $comment.find(".commentFooter").show();
                    $comment.find(".commentStatus").html("<span class='critical'>" + err.constructor.name + ": " + err.message + "</span>");
                    $comment.find(".commentFooter .commentControls").hide();
                }

                $comment.find(".commentModified").html("Edited by " + data[x].modifiedByName + " at " + data[x].modified);
                $comment.find(".commentSticky").addClass(data[x].sticky ? "active" : "");

                //tripwire.comments.data[id] = data[id];
            }
        }

        for (var x in tripwire.comments.data) {
            var id = tripwire.comments.data[x].id;

            if (!Object.find(data, "id", id)) {
                var $comment = $(".comment[data-id='"+id+"']");
                $comment.remove();
            }
        }

        tripwire.comments.data = data;
    }
}
tripwire.comments();

// Handles removing from Signatures section
tripwire.deleteSig = function(key) {
    var tr = $("#sigTable tr[data-id='"+key+"']");

    //Append empty space to prevent non-coloring
    $(tr).find('td:empty, a:empty').append("&nbsp;");

    $(tr)
        .find('td')
        .wrapInner('<div />')
        .parent()
        .find('td > div').animate({backgroundColor: "#4D0000"}, 1000).delay(1000).animate({backgroundColor: "#111"}, 1000)
        .slideUp(700, function(){
            // Remove countdown reference
            $(tr).find('span[data-age]').countdown("destroy");

            $(this).parent().parent().remove();
            $("#sigTable").trigger("update");
        });
}

// Handles changing Signatures section
// ToDo: Use native JS
tripwire.editSig = function(edit, disabled) {
    var disabled = disabled || false;
    var wormhole = {};

    if (edit.type == "wormhole") {
        var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == edit.id || wormhole.secondaryID == edit.id) return wormhole; })[0];
        if (!wormhole) return false;
        var otherSignature = edit.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID];
        if (!otherSignature) return false;

        if (edit.name) {
          leadsTo = tripwire.systems[otherSignature.systemID] ? "<a href='.?system="+tripwire.systems[otherSignature.systemID].name+"'>"+edit.name+"</a>" : edit.name;
        } else if (tripwire.aSigSystems[otherSignature.systemID]) {
            leadsTo = tripwire.aSigSystems[otherSignature.systemID];
        } else if (tripwire.systems[otherSignature.systemID]) {
            leadsTo = "<a href='.?system="+tripwire.systems[otherSignature.systemID].name+"'>"+tripwire.systems[otherSignature.systemID].name+"</a>";
        } else {
            leadsTo = "";
        }

        var row = "<tr data-id='"+edit.id+"' data-tooltip='' "+ (disabled ? 'disabled="disabled"' : '') +">"
            + "<td class='"+ options.signatures.alignment.sigID +"'>"+(edit.signatureID ? edit.signatureID.substring(0, 3)+"-"+(edit.signatureID.substring(3, 6) || "###") : "???-###")+"</td>"
            + "<td class='type-tooltip "+ options.signatures.alignment.sigType +"' data-tooltip=\""+this.whTooltip(wormhole)+"\">"+(wormhole[wormhole.parent+"ID"] == edit.id ? wormhole.type || "" : (wormhole.parent ? "K162" : ""))+"</td>"
            + "<td class='age-tooltip "+ options.signatures.alignment.sigAge + (parseInt(edit.lifeLength) === 0 ? " disabled" : "") +"' data-tooltip='"+this.ageTooltip(edit)+"'><span data-age='"+edit.lifeTime+"'></span></td>"
            + "<td class='"+ options.signatures.alignment.leadsTo +"'>"+(leadsTo || "")+"</td>"
            + "<td class='"+wormhole.life+" "+ options.signatures.alignment.sigLife +"'>"+wormhole.life+"</td>"
            + "<td class='"+wormhole.mass+" "+ options.signatures.alignment.sigMass +"'>"+wormhole.mass+"</td>"
            + "</tr>";

        var tr = $(row);
    } else {
        var row = "<tr data-id='"+edit.id+"' data-tooltip='' "+ (disabled ? 'disabled="disabled"' : '') +">"
            + "<td class='"+ options.signatures.alignment.sigID +"'>"+(edit.signatureID ? edit.signatureID.substring(0, 3)+"-"+(edit.signatureID.substring(3, 6) || "###") : "???-###")+"</td>"
            + "<td class='"+ options.signatures.alignment.sigType +"'>"+edit.type+"</td>"
            + "<td class='age-tooltip "+ options.signatures.alignment.sigAge + (parseInt(edit.lifeLength) === 0 ? " disabled" : "") +"' data-tooltip='"+this.ageTooltip(edit)+"'><span data-age='"+edit.lifeTime+"'></span></td>"
            + "<td class='"+ options.signatures.alignment.leadsTo +"' colspan='3'>"+(edit.name?linkSig(edit.name):'')+"</td>"
            + "</tr>";

        var tr = $(row);
    }

    Tooltips.attach($(tr).find("[data-tooltip]"));

    // Destroy the pervious countdown to prevent errors on a non-existant DOM element
    $("#sigTable tr[data-id='"+edit.id+"']").find('span[data-age]').countdown("destroy");
    $("#sigTable tr[data-id='"+edit.id+"']").replaceWith(tr);

    $("#sigTable").trigger("update");
    // Update counter
    if (wormhole.life == "critical") {
        $(tr).find('span[data-age]').countdown({until: moment.utc(edit.lifeLeft).toDate(), onExpiry: this.pastEOL, alwaysExpire: true, compact: true, format: this.ageFormat, serverSync: this.serverTime.getTime})
            .addClass('critical');
    } else {
        $(tr).find('span[data-age]').countdown({since: moment.utc(edit.lifeTime).toDate(), compact: true, format: this.ageFormat, serverSync: this.serverTime.getTime});
    }

    $(tr).effect("pulsate");
}

tripwire.esi = function() {
    var baseUrl = "https://esi.evetech.net";
    var userAgent = "Tripwire Client " + tripwire.version + " (" + window.location.hostname + ") - " + window.navigator.userAgent;
    var locationTimer, shipTimer, onlineTimer;
    this.esi.connection = true;
    this.esi.characters = {};

    var scopeError = function(characterID) {
        $("#tracking .tracking-clone[data-characterid='"+ characterID +"']").find(".alert").show();
    }
	
	var isExpired = function(tokenExpire) {
		return moment.utc(tokenExpire).subtract(5, "minutes").isBefore(moment());
	}
	
    this.esi.location = function() {
        clearTimeout(locationTimer);

        for (characterID in tripwire.esi.characters) {
            var character = tripwire.esi.characters[characterID];

            // Check for expiring token
            if (isExpired(character.tokenExpire)) {
                tripwire.data.esi = {"expired": true};
                continue;
            }

            $.ajax({
                url: baseUrl + "/v1/characters/"+ characterID +"/location/?" + $.param({"token": character.accessToken, "user_agent": userAgent}),
                // headers: {"Authorization": "Bearer "+ character.accessToken, "X-User-Agent": userAgent},
                type: "GET",
                dataType: "JSON",
                characterID: characterID
            }).done(function(data, status, xhr) {
                var character = tripwire.esi.characters[this.characterID];

                if (character) {
                    character.locationDate = moment(xhr.getResponseHeader("last-modified"), "ddd, DD MMMM YYYY HH:mm:ss").format();

                    if (character.systemID != data.solar_system_id) {
                        character.systemID = data.solar_system_id || null;
                        character.systemName = tripwire.systems[data.solar_system_id] ? tripwire.systems[data.solar_system_id].name : null;

                        $("#tracking .tracking-clone[data-characterid='"+ this.characterID +"']").find(".system").html(character.systemName || "&nbsp;");

                        // Send to Tripwire server on next refresh call
                        tripwire.data.tracking[this.characterID] = {
                            characterID: character.characterID,
                            characterName: character.characterName,
                            systemID: character.systemID,
                            systemName: character.systemName,
                            stationID: character.stationID,
                            stationName: character.stationName,
                            shipID: character.shipID,
                            shipName: character.shipName,
                            shipTypeID: character.shipTypeID,
                            shipTypeName: character.shipTypeName};
                    }

                    if (character.stationID != data.station_id) {
                        character.stationID = data.station_id || null;

                        if (data.station_id) {
                            tripwire.esi.stationLookup(data.station_id, this.characterID)
                                .always(function(data) {
                                    var character = tripwire.esi.characters[this.reference];

                                    character.stationName = data.name || null;
                                    $("#tracking .tracking-clone[data-characterid='"+ this.reference +"']").find(".station").html(data.name.substring(0, 17) + "..." || "&nbsp;").attr("data-tooltip", data.name);
                                    Tooltips.attach($("#tracking .tracking-clone[data-characterid='"+ this.reference +"'] .station[data-tooltip]"));

                                    // Send to Tripwire server on next refresh call
                                    tripwire.data.tracking[this.reference] = {
                                        characterID: character.characterID,
                                        characterName: character.characterName,
                                        systemID: character.systemID,
                                        systemName: character.systemName,
                                        stationID: character.stationID,
                                        stationName: character.stationName,
                                        shipID: character.shipID,
                                        shipName: character.shipName,
                                        shipTypeID: character.shipTypeID,
                                        shipTypeName: character.shipTypeName};
                                });
                        } else {
                            character.stationName = null;
                            // $("#tracking .tracking-clone[data-characterid='"+ this.characterID +"']").find(".station").html("&nbsp;").attr("data-tooltip", "&nbsp;");
                            Tooltips.detach($("#tracking .tracking-clone[data-characterid='"+ this.characterID +"'] .station[data-tooltip]"));

                            // Send to Tripwire server on next refresh call
                            tripwire.data.tracking[this.characterID] = {
                                characterID: character.characterID,
                                characterName: character.characterName,
                                systemID: character.systemID,
                                systemName: character.systemName,
                                stationID: character.stationID,
                                stationName: character.stationName,
                                shipID: character.shipID,
                                shipName: character.shipName,
                                shipTypeID: character.shipTypeID,
                                shipTypeName: character.shipTypeName};
                        }
                    }

                    if (options.tracking.active == this.characterID) {
                        tripwire.EVE(tripwire.esi.characters[options.tracking.active]);
                    }
                }
            }).fail(function(data) {
                if (data.status == 403) {
                    tripwire.refresh("refresh", {"esi": {"expired": true}});
                }
            }).always(function(data, status, xhr) {
                if (status != "success" && status != "abort" && tripwire.esi.connection == true) {
                    tripwire.esi.connection = false;
                    $("#esiConnectionSuccess, #esiConnectionError").click();
                    Notify.trigger("ESI Connection Failed", "red", false, "esiConnectionError");
                } else if (status == "success" && tripwire.esi.connection == false) {
                    tripwire.esi.connection = true;
                    $("#esiConnectionSuccess, #esiConnectionError").click();
                    Notify.trigger("ESI Connection Resumed", "green", 5000, "esiConnectionSuccess");
                }

                var headers = parseHeaders(xhr.getAllResponseHeaders());
                if (headers.warning) {
                  console.log('ESI API Warning: ', headers.warning, this.url);
                }
            });
        }

        locationTimer = setTimeout("tripwire.esi.location()", 5000);
    }

    this.esi.ship = function() {
        clearTimeout(shipTimer);

        for (characterID in tripwire.esi.characters) {
            var character = tripwire.esi.characters[characterID];

            // Check for expiring token
            if (isExpired(character.tokenExpire)) {
                tripwire.data.esi = {"expired": true};
                continue;
            }

            $.ajax({
                url: baseUrl + "/v1/characters/"+ characterID +"/ship/?" + $.param({"token": character.accessToken, "user_agent": userAgent}),
                // headers: {"Authorization": "Bearer "+ character.accessToken, "X-User-Agent": userAgent},
                type: "GET",
                dataType: "JSON",
                characterID: characterID
            }).done(function(data, status, xhr) {
                var character = tripwire.esi.characters[this.characterID];

                if (character) {
                    character.shipDate = moment(xhr.getResponseHeader("last-modified"), "ddd, DD MMMM YYYY HH:mm:ss").format();

                    if (character.shipID != data.ship_item_id) {
                        character.shipID = data.ship_item_id || null;

                        // Send to Tripwire server on next refresh call
                        tripwire.data.tracking[this.characterID] = {
                            characterID: character.characterID,
                            characterName: character.characterName,
                            systemID: character.systemID,
                            systemName: character.systemName,
                            stationID: character.stationID,
                            stationName: character.stationName,
                            shipID: character.shipID,
                            shipName: character.shipName,
                            shipTypeID: character.shipTypeID,
                            shipTypeName: character.shipTypeName};
                    }

                    if (character.shipName != data.ship_name) {
                        character.shipName = data.ship_name || null;
                        $("#tracking .tracking-clone[data-characterid='"+ this.characterID +"']").find(".shipname").html(data.ship_name || "&nbsp;");

                        // Send to Tripwire server on next refresh call
                        tripwire.data.tracking[this.characterID] = {
                            characterID: character.characterID,
                            characterName: character.characterName,
                            systemID: character.systemID,
                            systemName: character.systemName,
                            stationID: character.stationID,
                            stationName: character.stationName,
                            shipID: character.shipID,
                            shipName: character.shipName,
                            shipTypeID: character.shipTypeID,
                            shipTypeName: character.shipTypeName};
                    }

                    if (character.shipTypeID != data.ship_type_id) {
                        character.shipTypeID = data.ship_type_id || null;

                        if (data.ship_type_id) {
                            tripwire.esi.typeLookup(data.ship_type_id, this.characterID)
                                .always(function(data) {
                                    var character = tripwire.esi.characters[this.reference];

                                    character.shipTypeName = data.name || null;
                                    $("#tracking .tracking-clone[data-characterid='"+ this.reference +"']").find(".ship").html(data.name || "&nbsp;");

                                    // Send to Tripwire server on next refresh call
                                    tripwire.data.tracking[this.reference] = {
                                        characterID: character.characterID,
                                        characterName: character.characterName,
                                        systemID: character.systemID,
                                        systemName: character.systemName,
                                        stationID: character.stationID,
                                        stationName: character.stationName,
                                        shipID: character.shipID,
                                        shipName: character.shipName,
                                        shipTypeID: character.shipTypeID,
                                        shipTypeName: character.shipTypeName};
                                });
                        } else {
                            character.shipTypeName = null;
                            $("#tracking .tracking-clone[data-characterid='"+ this.characterID +"']").find(".ship").html("&nbsp;");

                            // Send to Tripwire server on next refresh call
                            tripwire.data.tracking[this.characterID] = {
                                characterID: character.characterID,
                                characterName: character.characterName,
                                systemID: character.systemID,
                                systemName: character.systemName,
                                stationID: character.stationID,
                                stationName: character.stationName,
                                shipID: character.shipID,
                                shipName: character.shipName,
                                shipTypeID: character.shipTypeID,
                                shipTypeName: character.shipTypeName};
                        }
                    }
                }
            }).fail(function(data) {
                if (data.status == 403) {
                    tripwire.refresh("refresh", {"esi": {"expired": true}});
                }
            }).always(function(data, status, xhr) {
                if (status != "success" && status != "abort" && tripwire.esi.connection == true) {
                    tripwire.esi.connection = false;
                    $("#esiConnectionSuccess, #esiConnectionError").click();
                    Notify.trigger("ESI Connection Failed", "red", false, "esiConnectionError");
                } else if (status == "success" && tripwire.esi.connection == false) {
                    tripwire.esi.connection = true;
                    $("#esiConnectionSuccess, #esiConnectionError").click();
                    Notify.trigger("ESI Connection Resumed", "green", 5000, "esiConnectionSuccess");
                }

                var headers = parseHeaders(xhr.getAllResponseHeaders());
                if (headers.warning) {
                  console.log('ESI API Warning: ', headers.warning, this.url);
                }
            });
        }

        shipTimer = setTimeout("tripwire.esi.ship()", 5000);
    }

    this.esi.online = function() {
        clearTimeout(onlineTimer);

        for (characterID in tripwire.esi.characters) {
            var character = tripwire.esi.characters[characterID];

            tripwire.esi.characterStatus(character.characterID, character)
                .done(function(data) {
                    if (data.online) {
                        $("#tracking .tracking-clone[data-characterid='"+ this.reference.characterID +"']").find(".online").removeClass("critical").addClass("stable");
                    } else {
                        $("#tracking .tracking-clone[data-characterid='"+ this.reference.characterID +"']").find(".online").removeClass("stable").addClass("critical");
                    }
                }).fail(function(data) {
                    if (data && data.status == 403) {
                        scopeError(this.reference.characterID);
                    }
                    $("#tracking .tracking-clone[data-characterid='"+ this.reference.characterID +"']").find(".online").removeClass("stable").addClass("critical");
                });
        }

        onlineTimer = setTimeout("tripwire.esi.online()", 60000);
    }

    this.esi.typeLookup = function(typeID, reference) {
        return $.ajax({
            url: baseUrl + "/v3/universe/types/"+ typeID +"/?" + $.param({"user_agent": userAgent}),
            // headers: {"X-User-Agent": userAgent},
            type: "GET",
            dataType: "JSON",
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.stationLookup = function(stationID, reference) {
        return $.ajax({
            url: baseUrl + "/v2/universe/stations/"+ stationID +"/?" + $.param({"user_agent": userAgent}),
            // headers: {"X-User-Agent": userAgent},
            type: "GET",
            dataType: "JSON",
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.setDestination = function(destinationID, characterID, clear_waypoints, beginning) {
        clear_waypoints = clear_waypoints ? clear_waypoints : false;
        beginning = beginning ? beginning : false;
        return $.ajax({
            url: baseUrl + "/v2/ui/autopilot/waypoint/?" + $.param({destination_id: destinationID, clear_other_waypoints: clear_waypoints, add_to_beginning: beginning}),
            headers: {"Authorization": "Bearer "+ tripwire.esi.characters[characterID].accessToken, "X-User-Agent": userAgent},
            type: "POST",
            dataType: "JSON"
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.showInfo = function(targetID, characterID) {
        return $.ajax({
            url: baseUrl + "/v1/ui/openwindow/information/?" + $.param({target_id: targetID}),
            headers: {"Authorization": "Bearer "+ tripwire.esi.characters[characterID].accessToken, "X-User-Agent": userAgent},
            type: "POST",
            dataType: "JSON"
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.characterStatus = function(characterID, reference) {
        return $.ajax({
            url: baseUrl + "/v2/characters/" + characterID + "/online/?" + $.param({"token": tripwire.esi.characters[characterID].accessToken, "user_agent": userAgent}),
            // headers: {"Authorization": "Bearer "+ tripwire.esi.characters[characterID].accessToken, "X-User-Agent": userAgent},
            type: "GET",
            dataType: "JSON",
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.eveStatus = function() {
        return $.ajax({
            url: baseUrl + "/v1/status/?" + $.param({"user_agent": userAgent}),
            // headers: {"X-User-Agent": userAgent},
            type: "GET",
            dataType: "JSON"
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.idLookup = function(eveIDs) {
        return $.ajax({
            url: baseUrl + "/v2/universe/names/?" + $.param({"user_agent": userAgent}),
            type: "POST",
            dataType: "JSON",
            contentType: "application/json",
            processData: false,
            data: JSON.stringify(eveIDs)
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.characterLookup = function(eveID, reference, async) {
        var async = typeof(async) !== 'undefined' ? async : true;
        return $.ajax({
            url: baseUrl + "/latest/characters/" + eveID + "/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON",
            async: async,
            eveID: eveID,
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.corporationLookup = function(eveID, reference, async) {
        var async = typeof(async) !== 'undefined' ? async : true;
        return $.ajax({
            url: baseUrl + "/v4/corporations/" + eveID + "/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON",
            async: async,
            eveID: eveID,
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.allianceLookup = function(eveID, reference, async) {
        var async = typeof(async) !== 'undefined' ? async : true;
        return $.ajax({
            url: baseUrl + "/v3/alliances/" + eveID + "/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON",
            async: async,
            eveID: eveID,
            reference: reference
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.search = function(searchString, categories, strict) {
        return $.ajax({
            url: baseUrl + "/v2/search/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON",
            contentType: "application/json",
            data: {"search": searchString, "categories": categories, "strict": strict}
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.universeJumps = function() {
        return $.ajax({
            url: baseUrl + "/v1/universe/system_jumps/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON"
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    this.esi.universeKills = function() {
        return $.ajax({
            url: baseUrl + "/v2/universe/system_kills/?" + $.param({"user_agent": userAgent}),
            type: "GET",
            dataType: "JSON"
        }).always(function(results, status, xhr) {
          var headers = parseHeaders(xhr.getAllResponseHeaders());
          if (headers.warning) {
            console.log('ESI API Warning: ', headers.warning, this.url);
          }
        });
    }

    // Wrapper to make lookups easier
    this.esi.fullLookup = function(eveIDs) {
        var promise = $.Deferred();

        tripwire.esi.idLookup(eveIDs)
            .done(function(data) {
                for (item in data) {
                    if (data[item].category == "character") {
                        tripwire.esi.characterLookup(data[item].id, data[item], false)
                            .done(function(characterData) {
                                $.extend(data[item], characterData);
                                tripwire.esi.corporationLookup(characterData.corporation_id, this.reference, false)
                                    .done(function(corporationData) {
                                        data[item].corporation = corporationData;
                                        if (corporationData.alliance_id) {
                                            tripwire.esi.allianceLookup(corporationData.alliance_id, this.reference, false)
                                                .done(function(allianceData) {
                                                    data[item].alliance = allianceData;
                                                });
                                        }
                                    });
                            });
                    } else if (data[item].category == "corporation") {
                        tripwire.esi.corporationLookup(data[item].id, data[item], false)
                            .done(function(corporationData) {
                                $.extend(data[item], corporationData);
                                if (corporationData.alliance_id) {
                                    tripwire.esi.allianceLookup(corporationData.alliance_id, this.reference, false)
                                        .done(function(allianceData) {
                                            data[item].alliance = allianceData;
                                        });
                                }
                            })
                    }
                }

                promise.resolve(data);
            });

        return promise;
    }

    this.esi.parse = function(characters) {
        for (characterID in tripwire.esi.characters) {
            if (!(characterID in characters)) {
                delete tripwire.esi.characters[characterID];
                $("#tracking .tracking-clone[data-characterid='"+ characterID +"']").remove();
                if (options.tracking.active == characterID) {
                    tripwire.EVE(false, true);
                    $("#removeESI").attr("disabled", "disabled");
                }
            }
        }

        for (characterID in characters) {
            if (options.tracking.active == "new") {
                options.tracking.active = characterID;
            }

            if (!(characterID in tripwire.esi.characters)) {
                var $clone = $("#tracking-clone").clone();
                $clone.attr("data-characterid", characterID);
                $clone.find(".avatar img").attr("src", "https://image.eveonline.com/Character/"+ characterID +"_32.jpg");
                $clone.find(".name").html(characters[characterID].characterName);
                $clone.removeAttr("id");
                $clone.removeClass("hidden");
                $clone.addClass("tracking-clone");

                if (options.tracking.active == characterID) {
                    $clone.addClass("active");
                    $("#removeESI").removeAttr("disabled");				}

                $("#tracking").append($clone);
                // Tooltips.attach($clone.find("[data-tooltip]"));
            }

            tripwire.esi.characters[characterID] = characters[characterID];
        }

        tripwire.esi.ship();
        tripwire.esi.location();
        tripwire.esi.online();
    }
}
tripwire.esi();

// Handles data from EVE in-game data
tripwire.EVE = function(EVE, characterChange) {
    var systemChange = this.client.EVE && this.client.EVE.systemChange || false;

    if (EVE) {
        // Automapper
        if (!characterChange) {
            // Did the system change or did it previously and we have yet to try an autoMapper call?
            if ((this.client.EVE && this.client.EVE.systemID != EVE.systemID) || systemChange == true) {
                systemChange = true;

                // Check if location was updated after the last ship update
                // if (moment(EVE.locationDate).isAfter(moment(this.client.EVE.shipDate))) {
                    systemChange = false;
                    tripwire.autoMapper(this.client.EVE.systemID, EVE.systemID);
                // }
            }
        }

        // System follower
        if (!characterChange && options.buttons.follow && (this.client.EVE && this.client.EVE.systemID != EVE.systemID) && $(".ui-dialog:visible").length == 0) {
            tripwire.systemChange(EVE.systemID);
        }

        if (!$("#search").hasClass("active")) {
            $("#currentSpan").show();
        }

        // Enable auto-mapper
        $("#toggle-automapper").removeClass("disabled");

        // Update current system
        if (EVE.systemID) {
            // add system to Leads To dropdown
            if ($("#dialog-signature [data-autocomplete='sigSystems']").hasClass("custom-combobox")) {
                $("#dialog-signature [data-autocomplete='sigSystems']").inlinecomplete("removeFromSelect");
                $("#dialog-signature [data-autocomplete='sigSystems']").inlinecomplete("addToSelect", tripwire.systems[EVE.systemID].name);
            }
            $("#EVEsystem").html(tripwire.systems[EVE.systemID].name).attr("href", ".?system="+ tripwire.systems[EVE.systemID].name);
        }
    } else {
        // Update current system
        $("#EVEsystem").html("");
        $("#currentSpan").hide();
        // Disable automapper
        $("#toggle-automapper").addClass("disabled");
        // remove system from Leads To dropdown
        if ($("#dialog-signature [data-autocomplete='sigSystems']").hasClass("custom-combobox")) {
            $("#dialog-signature [data-autocomplete='sigSystems']").inlinecomplete("removeFromSelect");
        }
    }

    this.client.EVE = {
        characterID: EVE.characterID,
        characterName: EVE.characterName,
        systemID: EVE.systemID,
        systemName: EVE.systemName,
        shipTypeID: EVE.shipTypeID,
        shipTypeName: EVE.shipTypeName,
        stationID: EVE.stationID,
        stationName: EVE.stationName,
        locationDate: EVE.locationDate,
        shipDate: EVE.shipDate,
        systemChange: systemChange
    };
}

tripwire.parse = function(server, mode) {
    var data = $.extend(true, {}, server);

    var updateSignatureTable = false;

    if (options.chain.active == null || (options.chain.tabs[options.chain.active] && options.chain.tabs[options.chain.active].evescout != true)) {
        if (options.masks.active != "273.0") {
            for (var key in data.signatures) {
                if (data.signatures[key].mask == "273.0") {
                    delete data.signatures[key];
                }
            }
        }
    }

    if (mode == 'refresh') {
        // preserve client.EVE across refresh otherwise tracking/automapper will be confused
        var EVE = this.client.EVE;
        this.client = server;
        this.client.EVE = EVE;

        for (var key in data.signatures) {
            if (data.signatures[key].systemID != viewingSystemID) {
                continue;
            }
            var disabled = data.signatures[key].mask == "273.0" && options.masks.active != "273.0" ? true : false;

            // Check for differences
            if (!tripwire.signatures.list[key]) {
				tripwire.signatures.list[key] = data.signatures[key];	// To reduce race condition chance
                this.addSig(data.signatures[key], {animate: true}, disabled);
                updateSignatureTable = true;
            } else if (tripwire.signatures.list[key].modifiedTime !== data.signatures[key].modifiedTime) {
                var edit = false;
                for (column in data.signatures[key]) {
                    if (data.signatures[key][column] != tripwire.signatures.list[key][column] && column != "editing") {
                        edit = true;
                    }
                }

                if (edit) {
                    this.editSig(data.signatures[key], disabled);
                } else {
                    // this.sigEditing(data.signatures[key]);
                }
            }
        }

        // Sigs needing removal
        for (var key in tripwire.signatures.list) {
            if (!data.signatures[key]) {
                this.deleteSig(key);
            }
        }
    } else if (mode == 'init' || mode == 'change') {
        this.client = server;

        for (var key in data.signatures) {
            if (data.signatures[key].systemID != viewingSystemID) {
                continue;
            }
            var disabled = data.signatures[key].mask == "273.0" && options.masks.active != "273.0" ? true : false;
			
			if(!tripwire.signatures.list[key]) {
				this.addSig(data.signatures[key], {animate: false}, disabled);
				updateSignatureTable = true;
			}
            if (data.signatures[key].editing) {
                this.sigEditing(data.signatures[key]);
            }
        }
    }

    if (updateSignatureTable) {
        $("#sigTable").trigger("update");
    }
    tripwire.signatures.list = data.signatures;

    // set the sig count in the UI
    var signatureCount = 0;
    $.map(data.signatures, function(signature) {signature.systemID == viewingSystemID ? signatureCount++ : null;});
    $("#signature-count").html(signatureCount);
}

// Handles pasting sigs from EVE
tripwire.pasteSignatures = function() {
    var processing = false;

    var rowParse = function(row) {
        var scanner = {};
        var columns = row.split("	"); // Split by tab
        var validScanGroups = ["Cosmic Signature", "Cosmic Anomaly", "Kosmische Anomalie", "Kosmische Signatur",
                                " ", " ", " ", " "];
        var validTypes = {"Gas Site": "Gas", "Data Site": "Data", "Relic Site": "Relic", "Ore Site": "Ore", "Combat Site": "Combat", "Wormhole": "Wormhole",
                            "Gasgebiet": "Gas", "Datengebiet": "Data", "Reliktgebiet": "Relic", "Mineraliengebiet": "Ore", "Kampfgebiet": "Combat", "Wurmloch": "Wormhole",
                            " ": "Gas", " ": "Data", " ": "Relic", " ": "Ore", " ": "Combat", "": "Wormhole", 
                            " ": "Gas", " ": "Data", " ": "Relic", " ": "Ore", " ": "Combat", "": "Wormhole"};

        for (var x in columns) {
            if (columns[x].match(/^([A-Z]{3}[-]\d{3})$/)) {
                scanner.id = columns[x].split("-");
                continue;
            }

            if (columns[x].match(/(\d([.|,]\d)?[ ]?(%))/) || columns[x].match(/(\d[.|,]?\d+\s(AU|AE|km|m|..||))/i)) { // Exclude scan % || AU
                continue;
            }

            if ($.inArray(columns[x], validScanGroups) != -1) {
                scanner.scanGroup = columns[x];
                continue;
            }

            if (validTypes[columns[x]]) {
                scanner.type = validTypes[columns[x]];
                continue;
            }

            if (columns[x] != "") {
                scanner.name = columns[x].trim();
            }
        }

        if (!scanner.id || scanner.id.length !== 2) {
            return false;
        }

        return scanner;
    }

    this.pasteSignatures.parsePaste = function(paste) {
        var paste = paste.split("\n");
        var payload = {"signatures": {"add": [], "update": []}, "systemID": viewingSystemID};
        var undo = [];
        processing = true;

        for (var i in paste) {
            var scanner = rowParse(paste[i]);

            if (scanner.id) {
                var signature = $.map(tripwire.client.signatures, function(signature) { if (signature.signatureID && signature.signatureID.toUpperCase() == scanner.id[0] + scanner.id[1]) return signature; })[0];
                if (signature) {
                    // Update signature (only non-wormholes can be updated to a wormhole)
                    if (scanner.type == "Wormhole" && signature.type != "wormhole") {
                        var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0] || {};
                        var otherSignature = wormhole.id ? (signature.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID]) : {};
                        payload.signatures.update.push({
                            "wormhole": {
                                "id": wormhole.id || null,
                                "type": wormhole.type || null,
                                "life": wormhole.life || "stable",
                                "mass": wormhole.mass || "stable"
                            },
                            "signatures": [
                                {
                                    "id": signature.id,
                                    "signatureID": signature.signatureID,
                                    "systemID": viewingSystemID,
                                    "type": "wormhole",
                                    "name": signature.name
                                },
                                {
                                    "id": otherSignature.id || null,
                                    "signatureID": otherSignature.signatureID || null,
                                    "systemID": otherSignature.systemID || null,
                                    "type": "wormhole",
                                    "name": otherSignature.name
                                }
                            ]
                        });

                        if (tripwire.client.wormholes[wormhole.id]) {
							undo.push({"wormhole": tripwire.client.wormholes[wormhole.id], "signatures": [tripwire.client.signatures[signature.id], tripwire.client.signatures[otherSignature.id]]});
						} else {
							// used to be just a regular signature
							undo.push(tripwire.client.signatures[signature.id]);
						}
                    // Make sure we are only updating when we have new info (we never turn wormholes into regular signatures)
                    } else if (signature.type != "wormhole" && ((scanner.type && scanner.type.toLowerCase() != signature.type) || (scanner.name && scanner.name != signature.name))) {
                        payload.signatures.update.push({
                            "id": signature.id,
                            "systemID": viewingSystemID,
                            "type": scanner.type || 'unknown',
                            "name": scanner.name,
                            "lifeLength": options.signatures.pasteLife * 60 * 60
                        });
                        undo.push(tripwire.client.signatures[signature.id]);
                    }
                } else {
                    // Add signature
                    if (scanner.type == "Wormhole") {
                        payload.signatures.add.push({
                            "wormhole": {
                                "type": null,
                                "parent": "initial",
                                "life": "stable",
                                "mass": "stable"
                            },
                            "signatures": [
                                {
                                    "signatureID": scanner.id[0] + scanner.id[1],
                                    "systemID": viewingSystemID,
                                    "type": "wormhole",
                                    "lifeLength": options.signatures.pasteLife * 60 * 60
                                },
                                {
                                    "signatureID": null,
                                    "systemID": null,
                                    "type": "wormhole",
                                    "lifeLength": options.signatures.pasteLife * 60 * 60
                                }
                            ]
                        });
                    } else {
                        payload.signatures.add.push({
                            "signatureID": scanner.id[0] + scanner.id[1],
                            "systemID": viewingSystemID,
                            "type": scanner.type || 'unknown',
                            "name": scanner.name,
                            "lifeLength": options.signatures.pasteLife * 60 * 60
                        });
                    }
                }
            }
        }

        if (payload.signatures.add.length || payload.signatures.update.length) {
            var success = function(data) {
                if (data.resultSet && data.resultSet[0].result == true) {
                    $("#undo").removeClass("disabled");

                    if (data.results) {
                        if (viewingSystemID in tripwire.signatures.undo) {
                            tripwire.signatures.undo[viewingSystemID].push({action: "add", signatures: data.results});
                        } else {
                            tripwire.signatures.undo[viewingSystemID] = [{action: "add", signatures: data.results}];
                        }
                    }

                    if (undo.length) {
                        if (viewingSystemID in tripwire.signatures.undo) {
                            tripwire.signatures.undo[viewingSystemID].push({action: "update", signatures: undo});
						} else {
                            tripwire.signatures.undo[viewingSystemID] = [{action: "update", signatures: undo}];
						}
                    }

                    sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
                }
            }

            var always = function(data) {
                processing = false;
            }

            tripwire.refresh('refresh', payload, success, always);
        } else {
            processing = false;
        }
    }

    this.pasteSignatures.init = function() {
        $(document).keydown(function(e)	{
            if ((e.metaKey || e.ctrlKey) && (e.keyCode == 86 || e.keyCode == 91) && !processing) {
                //Abort - user is in input or textarea
                if ($(document.activeElement).is("textarea, input")) return;

                $("#clipboard").focus();
            }
        });

        $("body").on("click", "#fullPaste", function(e) {
            e.preventDefault();

            var paste = $(this).data("paste").split("\n");
            var pasteIDs = [];
            var removes = [];
            var undo = [];

            for (var i in paste) {
                if (scan = rowParse(paste[i])) {
                    pasteIDs.push((scan.id[0] + scan.id[1]).toLowerCase());
                }
            }

            for (var i in tripwire.client.signatures) {
                var signature = tripwire.client.signatures[i];

                if (signature.systemID == viewingSystemID && signature.signatureID && $.inArray(signature.signatureID.toLowerCase(), pasteIDs) === -1 && signature.signatureID !== "???") {
                    if (signature.type == "wormhole") {
                        var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0] || {};
                        var otherSignature = wormhole.id ? (signature.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID]) : {};
                        if (wormhole.type !== "GATE") {
                            removes.push(wormhole);
                            undo.push({"wormhole": wormhole, "signatures": [signature, otherSignature]});
                        }
                    } else {
                        removes.push(signature.id);
                        undo.push(signature);
                    }
                }
            }

            if (removes.length > 0) {
                var payload = {"signatures": {"remove": removes}};

                var success = function(data) {
                    if (data.resultSet && data.resultSet[0].result == true) {
                        $("#undo").removeClass("disabled");
                        if (viewingSystemID in tripwire.signatures.undo) {
                            tripwire.signatures.undo[viewingSystemID].push({action: "remove", signatures: undo});
                        } else {
                            tripwire.signatures.undo[viewingSystemID] = [{action: "remove", signatures: undo}];
                        }

                        sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
                    }
                }

                tripwire.refresh('refresh', payload, success);
            }
        });

        $("#clipboard").on("paste", function(e) {
            e.preventDefault();
            var paste = window.clipboardData ? window.clipboardData.getData("Text") : (e.originalEvent || e).clipboardData.getData('text/plain');

            $("#clipboard").blur();
            Notify.trigger("Paste detected<br/>(<a id='fullPaste' href=''>Click to delete missing sigs</a>)");
            $("#fullPaste").data("paste", paste);
            tripwire.pasteSignatures.parsePaste(paste);
        });
    }

    this.pasteSignatures.init();
}
tripwire.pasteSignatures();

tripwire.redo = function() {
    if (tripwire.signatures.redo[viewingSystemID].length > 0) {
        $("#redo").addClass("disabled");
        var lastIndex = tripwire.signatures.redo[viewingSystemID].length -1;
        var data = {"systemID": viewingSystemID, "signatures": {"add": [], "remove": [], "update": []}};

        var redoItem = tripwire.signatures.redo[viewingSystemID][lastIndex];
        var undo = $.map(redoItem.signatures, function(signature) {
            // grab the current signature so we can restore the way it is now
            if (signature.wormhole && tripwire.client.wormholes[signature.wormhole.id]) {
                // it was a wormhole and still is
                return {"wormhole": tripwire.client.wormholes[signature.wormhole.id], "signatures": [tripwire.client.signatures[signature.signatures[0].id], tripwire.client.signatures[signature.signatures[1].id]]};
            } else if (tripwire.client.signatures[signature.id] && tripwire.client.signatures[signature.id].type == "wormhole") {
                // it was a regular signature but is now a wormhole
                var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
                return {"wormhole": wormhole, "signatures": [tripwire.client.signatures[wormhole.initialID], tripwire.client.signatures[wormhole.secondaryID]]};
            } else if (signature.wormhole && tripwire.client.signatures[signature.signatures[0].id]) {
                // it was a wormhole but is now a regular signature
                return tripwire.client.signatures[signature.signatures[0].id];
            } else {
                // it was a regular signature and still is
                return tripwire.client.signatures[signature.id];
            }
        });

        switch(redoItem.action) {
            case "add":
                data.signatures.add = data.signatures.add.concat(redoItem.signatures);
                break;
            case "remove":
                data.signatures.remove = data.signatures.remove.concat($.map(redoItem.signatures, function(signature) { return signature.wormhole ? signature.wormhole : signature.id }));
                break;
            case "update":
                data.signatures.update = data.signatures.update.concat(redoItem.signatures);
                break;
        }

        var success = function(data) {
            if (data.resultSet && data.resultSet[0].result == true) {
                tripwire.signatures.redo[viewingSystemID].pop();

                $("#undo").removeClass("disabled");
                if (viewingSystemID in tripwire.signatures.undo) {
                    if (redoItem.action == "add") {
                        // we are adding new signatures we removed so we need the new ids
                        tripwire.signatures.undo[viewingSystemID].push({"action": redoItem.action, "signatures": data.results});
                    } else if (redoItem.action == "update") {
                        tripwire.signatures.undo[viewingSystemID].push({"action": redoItem.action, "signatures": undo});
                    } else {
                        tripwire.signatures.undo[viewingSystemID].push({action: redoItem.action, signatures: redoItem.signatures});
                    }
                } else {
                    if (redoItem.action == "add") {
                        tripwire.signatures.undo[viewingSystemID] = [{"action": redoItem.action, "signatures": data.results}];
                    } else if (redoItem.action == "update") {
                        tripwire.signatures.undo[viewingSystemID] = [{"action": redoItem.action, "signatures": undo}];
                    } else {
                        tripwire.signatures.undo[viewingSystemID] = [{action: redoItem.action, signatures: redoItem.signatures}];
                    }
                }

                sessionStorage.setItem("tripwire_redo", JSON.stringify(tripwire.signatures.redo));
                sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
            }
        }

        var always = function(data) {
            if (tripwire.signatures.redo[viewingSystemID].length > 0) {
                $("#redo").removeClass("disabled");
            }
        }

        tripwire.refresh('refresh', data, success, always);
    }
}

// Handles pulling TQ status & player count
tripwire.serverStatus = function() {
    this.data;
    this.timer;

    clearTimeout(tripwire.serverStatus.timer);

    tripwire.esi.eveStatus()
        .always(function(data) {
            if (data && data.players && data.players > 0) {
                if (!tripwire.serverStatus.data || tripwire.serverStatus.data.players !== data.players) {
                    $('#serverStatus').html("<span class='"+(data.players > 0 ? 'stable' : 'critical')+"'>TQ</span>: "+numFormat(data.players));

                    if (tripwire.serverStatus.data) {
                        $("#serverStatus").effect('pulsate', {times: 5});
                    }
                }

                tripwire.serverStatus.data = data;
            } else {
                $('#serverStatus').html("<span class='critical'>TQ</span>");
            }

            tripwire.serverStatus.timer = setTimeout("tripwire.serverStatus();", 15000);
        });
}
tripwire.serverStatus();

tripwire.sync = function(mode, data, successCallback, alwaysCallback) {
    var data = typeof(data) === "object" ? $.extend(true, {}, data) : {};

    // Grab any pending changes
    $.extend(true, data, tripwire.data);

    // Remove old timer to prevent multiple
    if (this.timer) clearTimeout(this.timer);
    if (this.xhr) {
		console.log('Awaiting existing XHR ' + this.xhr.data.mode + ': ', this.xhr);
		tripwire.data = data;
		this.timer = setTimeout(function() { tripwire.sync(mode, data, successCallback, alwaysCallback); }, 50);
		return false;
	}

    if (mode == 'refresh' || mode == 'change') {
        data.signatureCount = tripwire.serverSignatureCount;
        data.signatureTime = Object.maxTime(this.client.signatures, "modifiedTime");

        data.flareCount = chain.data.flares ? chain.data.flares.flares.length : 0;
        data.flareTime = chain.data.flares ? chain.data.flares.last_modified : 0;

        data.commentCount = Object.size(this.comments.data);
        data.commentTime = Object.maxTime(this.comments.data, "modified");

        data.activity = this.activity;
    } else {
        // Expand Tripwire with JSON data from EVE Data Dump and other static data
        $.extend(this, appData);

        this.aSystems = $.map(this.systems, function(system) { return system.name; });
        this.aSigSystems = ["Null-Sec", "Low-Sec", "High-Sec", "Class-1", "Class-2", "Class-3", "Class-4", "Class-5", "Class-6", "Class-13", "Triglavian"];
        $.merge(this.aSigSystems, this.aSystems.slice());

        $(".systemsAutocomplete").inlinecomplete({source: this.aSystems, maxSize: 10, delay: 0});
    }

    data.mode = mode != "init" ? "refresh" : "init";
    data.systemID = viewingSystemID;
    data.systemName = viewingSystem;
    data.instance = tripwire.instance;
    data.version = tripwire.version;

    this.xhr = $.ajax({
        url: "refresh.php",
        data: data,
        type: "POST",
        dataType: "JSON",
        cache: false
    }).done(function(data) {
        if (data) {
            tripwire.server = data;
            if(data.signatures) { // Save this count before we delete entries
                tripwire.serverSignatureCount = Object.size(data.signatures);
            }

            if (data.wormholes) {
                // Purge bad wormhole signatures
                var wormholeInitialIDs = {};
                var wormholeSecondaryIDs = {};
                Object.values(data.wormholes).forEach(function (wh) {
                    wormholeInitialIDs[parseInt(wh.initialID)] = wh.id;
                    wormholeSecondaryIDs[parseInt(wh.secondaryID)] = wh.id;
                })
                for (var i in data.signatures) {
                  if (data.signatures[i].type == "wormhole") {
                    var id = data.signatures[i].id;
                    if (wormholeInitialIDs[id] === undefined && wormholeSecondaryIDs[id] === undefined) {
                      delete data.signatures[i];
                    }
                  }
                }
            }

            if (data.esi) {
                tripwire.esi.parse(data.esi);
            }

            if (data.sync) {
                tripwire.serverTime.time = new Date(data.sync);
            }

            if (data.signatures) {
                tripwire.parse(data, mode);
            }

            if (data.comments) {
                tripwire.comments.parse(data.comments);
            }

            if (data.wormholes || data.occupied || data.flares) {
                tripwire.chainMap.parse({"map": data.wormholes || null, "occupied": data.occupied || null, "flares": data.flares || null});
            } else if (chain.data.occupied && chain.data.occupied.length && !data.occupied) {
                // send update to remove all occupied system indicators
                tripwire.chainMap.parse({"occupied": []});
            }

            tripwire.active(data.activity);

            if (data.notify && !$("#serverNotification")[0]) Notify.trigger(data.notify, "yellow", false, "serverNotification");
			
			$('[data-command=ping]')[data.discord_integration ? 'show' : 'hide']();
        }

        tripwire.data = {tracking: {}, esi: {}};
        successCallback ? successCallback(data) : null;
    }).always(function(data, status) {
        tripwire.timer = setTimeout("tripwire.refresh();", tripwire.refreshRate);

        alwaysCallback ? alwaysCallback(data) : null;

        if (data.status == 403) {
            window.location.href = ".";
        } else if (status != "success" && status != "abort" && tripwire.connected == true) {
            tripwire.connected = false;
            $("#ConnectionSuccess").click();
            Notify.trigger("Error syncing with server", "red", false, "connectionError");
        } else if (status == "success" && tripwire.connected == false) {
            tripwire.connected = true;
            $("#connectionError").click();
            Notify.trigger("Successfully reconnected with server", "green", 5000, "connectionSuccess");
        }
		
		tripwire.xhr = null;
    });
	this.xhr.data = data;
	
    return true;
}
tripwire.sync("init");

// Change the currently viewed system
tripwire.systemChange = function(systemID, mode) {
	const system = systemAnalysis.analyse(systemID);
		
    if (mode != "init") {
        $("#infoSecurity").removeClass();
        $("#infoStatics").empty();

        viewingSystem = system.name;
        viewingSystemID = systemID;

        // Reset activity
        activity.refresh(true);

        // Reset signatures
        $("#sigTable span[data-age]").countdown("destroy");
        $("#sigTable tbody").empty();
        $("#signature-count").html(0);
        tripwire.signatures.list = {};
        tripwire.client.signatures = null;

        // Reset chain map
        chain.redraw();

        // Reset comments
        $("#notesWidget .content .comment:visible").remove();
        tripwire.comments.data = null;

        // Change the URL & history
        history.replaceState(null, null, "?system="+viewingSystem);

        tripwire.refresh("change");
    }

    // Change the title
    document.title = system.name + " - " + app_name;

    $("#infoSystem").text(system.name);

    // Current system favorite
    $.inArray(parseInt(viewingSystemID), options.favorites) != -1 ? $("#system-favorite").attr("data-icon", "star").addClass("active") : $("#system-favorite").attr("data-icon", "star-empty").removeClass("active");
	
    if (system.class) {
        // Security
        $("#infoSecurity").html("<span class='wh pointer'>Class " + system.class + "</span>");

        // Effects
        if (system.effect) {
            var tooltip = "<table cellpadding=\"0\" cellspacing=\"1\">";
            for (var x in tripwire.effects[system.effect]) {
                var effect = tripwire.effects[system.effect][x].name;
                var base = tripwire.effects[system.effect][x].base;
                var bad = tripwire.effects[system.effect][x].bad;
                var whClass = system.class > 6 ? 6 : system.class;
                var modifier = 0;

                switch (Math.abs(base)) {
                    case 15:
                        modifier = base > 0 ? 7 : -7;
                        break;
                    case 30:
                        modifier = base > 0 ? 14 : -14;
                        break;
                    case 60:
                        modifier = base > 0 ? 28 : -28;
                        break;
                }

                tooltip += "<tr><td>" + effect + "</td><td style=\"padding-left: 25px; text-align: right;\" class=\"" + (bad ? "critical" : "stable") + "\">";
                tooltip += base + (modifier * (whClass -1)) + "%</td></tr>";
            }
            tooltip += "</table>";
            $("#infoSecurity").append("&nbsp;<span class='pointer' data-tooltip='" + tooltip + "'>" + system.effect + "</span>");
        }

        // Statics
        for (var x in system.statics) {
            var type = system.statics[x];
            var wormhole = tripwire.wormholes[type];
            var color = "wh";

            switch (wormhole.leadsTo) {
                case "High-Sec":
                    color = "hisec";
                    break;
                case "Low-Sec":
                    color = "lowsec";
                    break;
                case "Null-Sec":
                    color = "nullsec";
                    break;
            }

            $("#infoStatics").append("<div><span class='"+ color +"'>&#9679;</span> <b>"+ wormhole.leadsTo +"</b> via <span class='"+ color +"'>"+ type +"</span></div>");
        }

        // Faction
        $("#infoFaction").html("&nbsp;");
    } else {
        // Security
		const securityText = {HS: 'High-Sec', LS: 'Low-Sec', NS: 'Null-Sec', 'Trig': 'Triglavian' }[system.systemTypeName];
       $("#infoSecurity").addClass(system.systemTypeClass).html(securityText + " " + system.baseSecurity.toFixed(2) + system.systemTypeModifiers.join(' '));

        // Faction
        $("#infoFaction").html(system.factionID ? tripwire.factions[system.factionID].name : "&nbsp;");
		
		// Route to favourites
		for (var fi in options.favorites) {
			const f = options.favorites[fi];
			const path = guidance.findShortestPath(tripwire.map.shortest, f - 30000000, viewingSystemID - 30000000);
			if(path) { $('#infoStatics').append('<p><b><a href=".?system=' + tripwire.systems[f].name + '">' +tripwire.systems[f].name + '</a></b>: ' + chain.renderPath(path) + '</p>'); }
		}
    }
	
	Tooltips.attach($("#infoStatics [data-tooltip]"));
    Tooltips.attach($("#infoSecurity [data-tooltip]"));

    // Region
    $("#infoRegion").text(tripwire.regions[system.regionID].name);

    // Info Links
    $("#infoWidget .infoLink").each(function() {
        this.href = $(this).data("href").replace(/\$systemName/gi, system.name).replace(/\$systemID/gi, systemID);
    });

    // Reset undo/redo
    tripwire.signatures.undo[systemID] && tripwire.signatures.undo[systemID].length > 0 ? $("#undo").removeClass("disabled") : $("#undo").addClass("disabled");
    tripwire.signatures.redo[systemID] && tripwire.signatures.redo[systemID].length > 0 ? $("#redo").removeClass("disabled") : $("#redo").addClass("disabled");

    // Reset delete signature icon
    $("#sigTable tr.selected").length == 0 ? $("#signaturesWidget #delete-signature").addClass("disabled") : $("#signaturesWidget #delete-signature").removeClass("disabled");
}
tripwire.systemChange(viewingSystemID, "init");

var tutorial;

// infoWidget
$("#infoWidget .tutorial").click(function() {
    tutorial = introJs().setOptions({
        showStepNumbers: false,
        steps: [
            {
                element: document.querySelector("#infoWidget"),
                intro: "<h4>System information widget</h4><br/><p>Displays information on the currently <b>selected</b> Tripwire system.</p>"
            },
            {
                element: document.querySelector("#infoGeneral"),
                intro: "<p>This section includes:<br/>System Name<br/>Security Rating<br/>Region<br/>Owning Faction Name</p><br/><p>If the selected system is a wormhole with a system effect, that will also be shown - hover over it to view the effect breakdown.</p>"
            },
            {
                element: document.querySelector("#activityGraph"),
                intro: "<p>This is the graph containing historical ship jump and kill information from the EVE API.</p><br/><p>This data is only available for K-Space systems and not wormhole systems.</p><br/><p>The EVE API updates this data each hour, so this graph will update itself at the top of every hour.</p>"
            },
            {
                element: $("#activityGraph svg > g > g:nth-child(5)")[0],
                intro: "<p>Each category can be toggled by clicking these keys to drill down the graph into finer detail.</p>"
            },
            {
                element: document.querySelector("#activityGraphControls"),
                intro: "<p>Select different lengths of historical data to adjust the graph to display more or less information.</p>"
            },
            {
                element: document.querySelector("#infoStatics"),
                intro: "<p>If a wormhole system is selected, the publicaly known static wormholes will appear here.</p>"
            },
            {
                element: document.querySelector("#infoLinks"),
                intro: "<p>These are some quick links to various sites for this specific system.</p>"
            },
            {
                element: document.querySelector("#system-favorite"),
                intro: "<p>This toggles wether this is a 'favorite' system, orange is active.</p><br/><p>'Favorite' systems can be rendered in the chain map to be able to see how far away trade hub systems are from your wormhole chain K-Space exits.</p>"
            }
        ]
    }).start();
});

// signaturesWidget
$("#signaturesWidget .tutorial").click(function() {
    tutorial = introJs().setOptions({
        showStepNumbers: false,
        steps: [
            {
                element: document.querySelector("#signaturesWidget"),
                intro: "<h4>System signatures widget</h4><br/><p>Displays all signatures and wormholes in the currently <b>selected</b> Tripwire system.</p>"
            },
            {
                element: document.querySelector("#add-signature"),
                intro: "<p>Add new signatures and wormholes manually by clicking the + icon.</p><br/><p>Copy & Paste EVE scanner results anywhere once Tripwire has focus to add or update signatures, repeated pastes will only update with new information.</p>"
            },
            {
                element: document.querySelector("#delete-signature"),
                intro: "<p>Click here or use the keyboard shortcut <b>DELETE</b> to delete <b>selected</b> signatures from this system.</p><br/><p>Click on a row to select it, click multiple rows to delete multiple signatures at once, click a selected row again to unselect it.</p>"
            },
            {
                element: document.querySelector("#signature-count"),
                intro: "<p>This shows the current count of signatures, including wormholes, in the selected system.</p>"
            },
            {
                element: document.querySelector("#undo"),
                intro: "<p>Click here or use the keyboard shortcut <b>CTRL-Z</b> to undo the last changes you made in this sytem (this includes clipboard pasted changes).</p><br/><p>You can undo multiple times as history is kept in the browser.</p>"
            },
            {
                element: document.querySelector("#redo"),
                intro: "<p>Click here or use the keyboard shortcut <b>CTRL-Y</b> to redo the last changes you made in this system (this includes clipboard pasted changes).</p><br/><p>You can redo multiple times as history is kept in the browser.</p>"
            },
            {
                element: document.querySelector("#toggle-automapper"),
                intro: "<p>Click here to toggle the Auto-mapper feature on (orange) or off.</p><br/><p>This feature only works when an in-game character is being actively tracked, otherwise this icon appears disabled.</p><br/><p>The automapper will watch for a change in your in-game system not via a star gate and try to automatically add or update wormholes.</p><br/><p>First it tries to seach for wormholes already added but missing a leads to system, this includes via wormhole type (B274) or with a leads to of 'High-Sec' for example.</p><br/><p>Next it searches for wormholes without any type or leads to at all.</p><br/><p>Finally if there are no wormholes or they all have a leads to system already, it will add a new wormhole.</p><br/><p>If at any time if finds multiple wormholes it can update, a dialog window will appear asking which wormhole you want to update.</p>"
            },
            {
                element: document.querySelector("#sigTable"),
                intro: "<p>Each column can be sorted by clicking the column label, sort by multiple columns by holding the shift key.</p><br/><p>Right-click a column to change the text-alignment.</p>"
            }
        ]
    }).start();
});

// notesWidget
$("#notesWidget .tutorial").click(function(e) {
    e.preventDefault();

    tutorial = introJs().setOptions({
        showStepNumbers: false,
        exitOnEsc: false,
        exitOnOverlayClick: false,
        skipLabel: "Abort",
        steps: [
            {
                element: document.querySelector("#notesWidget"),
                intro: "<h4>System notes widget</h4><br/><p>Displays comments based on the currently <b>selected</b> Tripwire system.</p><br/><p>The rest of this tutorial will guide you through actually adding a comment, but don't worry we will switch you to your private Tripwire mask so we don't disturb anyone else.</p><br/><p>When you finish or leave this tutorial we will switch you back to your previous Tripwire mask.</p>"
            },
            {
                element: document.querySelector("#add-comment"),
                intro: "<p>Now click the + icon to begin adding a new comment in this system (" + viewingSystem + ").</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>Type some basic text now and click save.</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>This is our newly created comment. Hover over the comment with your mouse to see additional information and controls.</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>You can click the 'pin' or 'sticky' button to toggle showing this comment for every system, not just this system.</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>Use the <b>Edit</b> to modify a comment and <b>Delete</b> to remove a comment.</p><br/><p>You can also quickly edit any comment by simply doubling clicking anywhere on it.</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>Click on the <b>Edit</b> now on our comment.</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>The toolbar at the top allows you to customize your notes.</p><br/><p>You can also click on the <b>Maximize/Minimize</b> button (the far right toolbar icon) to edit this comment in full screen mode.</p><br/><p>In full screen mode you will see 1 new button added to the toolbar to view the source code of the comment where you can write HTML, CSS, and even Javascript in your notes!</p>"
            },
            {
                element: document.querySelector("#notesWidget"),
                intro: "<p>This concludes the tutorial, we will now switch you back to your previous Tripwire mask and delete the comment we created.</p>"
            }
        ]
    }).start();

    tutorial.onchange(function(element) {
        switch(tutorial._currentStep) {
            case 1:
                $(".introjs-prevbutton, .introjs-nextbutton").hide();

                console.log("switch mask to private");
                tutorial.previousMask = options.masks.active;
                options.masks.active = options.character.id + ".1";
                options.save();

                tutorial.stepFunc = function() {
                    setTimeout(function() {
                        tutorial._options.steps[2].element = $("#notesWidget").find(".comment:has(.cke_toolbar)")[0];
                        tutorial.setOption("steps", tutorial._options.steps);

                        tutorial.exiting = false;
                        tutorial.exit().start().goToStep(3);
                        tutorial.exiting = true;
                    }, 200);
                }

                $("#notesWidget #add-comment").on("click", tutorial.stepFunc);
                break;
            case 2:
                $(".introjs-prevbutton, .introjs-nextbutton").hide();
                $("#notesWidget #add-comment").off("click", tutorial.stepFunc);

                tutorial.stepFunc = function() {
                    tutorial.comment = $(this).closest(".comment");
                    setTimeout(function() {
                        tutorial._options.steps[3].element = tutorial.comment[0];
                        tutorial._options.steps[4].element = tutorial.comment.find(".commentSticky")[0];
                        tutorial._options.steps[5].element = tutorial.comment.find(".commentControls")[0];
                        tutorial._options.steps[6].element = tutorial.comment.find(".commentControls")[0];
                        tutorial.setOption("steps", tutorial._options.steps);

                        tutorial.exiting = false;
                        tutorial.exit().start().goToStep(4);
                        tutorial.exiting = true;
                    }, 200);
                }

                $("#notesWidget").on("click", ".commentSave", tutorial.stepFunc);
                break;
            case 6:
                $(".introjs-prevbutton, .introjs-nextbutton").hide();
                $("#notesWidget").off("click", ".commentSave", tutorial.stepFunc);

                tutorial.stepFunc = function() {
                    setTimeout(function() {
                        tutorial._options.steps[7].element = $("#notesWidget").find(".comment:has(.cke_toolbar)")[0];
                        tutorial._options.steps[8].element = $("#notesWidget").find(".comment:has(.cke_toolbar)")[0];
                        tutorial.setOption("steps", tutorial._options.steps);

                        tutorial.exiting = false;
                        tutorial.exit().start().goToStep(8);
                        tutorial.exiting = true;
                    }, 200);
                }

                $("#notesWidget").on("click", ".commentEdit", tutorial.stepFunc);
                break;
        }
    });

    tutorial.onexit(function() {
        if (tutorial.exiting) {
            $(".commentCancel:visible").click();
            // delete the tutorial comment that was created
            if (tutorial.comment) {
                var data = {"mode": "delete", "commentID": tutorial.comment.data("id")};

                $.ajax({
                    url: "comments.php",
                    type: "POST",
                    data: data,
                    dataType: "JSON"
                }).done(function(data) {
                    if (data && data.result == true) {
                        tutorial.comment.remove();
                    }
                });
            }

            if (tutorial.previousMask) {
                setTimeout(function() {
                    console.log("change mask back, delete comment", tutorial.previousMask);
                    options.masks.active = tutorial.previousMask;
                    options.save();
                }, 200);
            }

            // remove event listeners
            $("#notesWidget #add-comment").off("click", tutorial.stepFunc);
            $("#notesWidget").off("click", ".commentSave", tutorial.stepFunc);
            $("#notesWidget").off("click", ".commentEdit", tutorial.stepFunc);
            $("#notesWidget").off("click", ".cke_toolgroup:has(.cke_button__toolbarswitch)", tutorial.stepFunc);
        }
    });

    tutorial.previousMask;
    tutorial.comment;
    tutorial.stepFunc;
    tutorial.exiting = true;
});

tripwire.undo = function() {
    if (tripwire.signatures.undo[viewingSystemID].length > 0) {
        $("#undo").addClass("disabled");
        var lastIndex = tripwire.signatures.undo[viewingSystemID].length -1;
        var data = {"systemID": viewingSystemID, "signatures": {"add": [], "remove": [], "update": []}};

        var undoItem = tripwire.signatures.undo[viewingSystemID][lastIndex];
        var redo = $.map(undoItem.signatures, function(signature) {
            // grab the current signature so we can restore the way it is now
            if (signature.wormhole && tripwire.client.wormholes[signature.wormhole.id]) {
                // it was a wormhole and still is
                return {"wormhole": tripwire.client.wormholes[signature.wormhole.id], "signatures": [tripwire.client.signatures[signature.signatures[0].id], tripwire.client.signatures[signature.signatures[1].id]]};
            } else if (tripwire.client.signatures[signature.id] && tripwire.client.signatures[signature.id].type == "wormhole") {
                // it was a regular signature but is now a wormhole
                var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
                return {"wormhole": wormhole, "signatures": [tripwire.client.signatures[wormhole.initialID], tripwire.client.signatures[wormhole.secondaryID]]};
            } else if (signature.wormhole && tripwire.client.signatures[signature.signatures[0].id]) {
                // it was a wormhole but is now a regular signature
                return tripwire.client.signatures[signature.signatures[0].id];
            } else {
                // it was a regular signature and still is
                return tripwire.client.signatures[signature.id];
            }
        });

        switch(undoItem.action) {
            case "add":
                data.signatures.remove = data.signatures.remove.concat($.map(undoItem.signatures, function(signature) { return signature.wormhole ? signature.wormhole : signature.id }));
                break;
            case "remove":
                data.signatures.add = data.signatures.add.concat(undoItem.signatures);
                break;
            case "update":
                data.signatures.update = data.signatures.update.concat(undoItem.signatures);
                break;
        }

        var success = function(data) {
            if (data.resultSet && data.resultSet[0].result == true) {
                tripwire.signatures.undo[viewingSystemID].pop();

                $("#redo").removeClass("disabled");
                if (viewingSystemID in tripwire.signatures.redo) {
                    if (undoItem.action == "remove") {
                        // we are adding new signatures we removed so we need the new ids
                        tripwire.signatures.redo[viewingSystemID].push({"action": undoItem.action, "signatures": data.results});
                    } else if (undoItem.action == "update") {
                        tripwire.signatures.redo[viewingSystemID].push({"action": undoItem.action, "signatures": redo});
                    } else {
                        tripwire.signatures.redo[viewingSystemID].push({"action": undoItem.action, "signatures": undoItem.signatures});
                    }
                } else {
                    if (undoItem.action == "remove") {
                        tripwire.signatures.redo[viewingSystemID] = [{"action": undoItem.action, "signatures": data.results}];
                    } else if (undoItem.action == "update") {
                        tripwire.signatures.redo[viewingSystemID] = [{"action": undoItem.action, "signatures": redo}];
                    } else {
                        tripwire.signatures.redo[viewingSystemID] = [{"action": undoItem.action, "signatures": undoItem.signatures}];
                    }
                }

                sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
                sessionStorage.setItem("tripwire_redo", JSON.stringify(tripwire.signatures.redo));
            }
        }

        var always = function(data) {
            if (tripwire.signatures.undo[viewingSystemID].length > 0) {
                $("#undo").removeClass("disabled");
            }
        }

        tripwire.refresh('refresh', data, success, always);
    }
}

var activity = new function() {
	this.graph;
	this.options;
	this.view;
	this.span = 24;
	this.columns = [
		{id: "time", label: "Time", role: "domain", type: "string", calc: function(d, r) { return d.getValue(r, 0) + "h"; }},
		{id: "jumps", label: "Jumps", role: "data", type: "number", sourceColumn: 1, column: 1, title: "Jumps"},
		{id: "podkills", label: "Pod Kills", role: "data", type: "number", sourceColumn: 2, column: 2, title: "Pod Kills"},
		{id: "shipkills", label: "Ship Kills", role: "data", type: "number", sourceColumn: 3, column: 3, title: "Ship Kills"},
		{id: "npckills", label: "NPC Kills", role: "data", type: "number", sourceColumn: 4, column: 4, title: "NPC Kills"},
		//{id: "annotationLabel", label: "Test", role: "annotation", type: "string", sourceColumn: 5, title: "Test"},
		//{id: "annotationText", label: "Test", role: "annotationText", type: "string", sourceColumn: 6, title: "Test"}
	];

	this.getData = function(span, cache) {
		var span = typeof(span) !== "undefined" ? span : this.span;
		var cache = typeof(cache) !== "undefined" ? cache : true;

		// Google hasn't finished loading yet
		if (!activity.graph) {
				setTimeout(function() {activity.getData(span, cache)}, 500);
				return false;
		}

		return $.ajax({
			url: "activity_graph.php",
			data: {systemID: viewingSystemID, time: span},
			type: "GET",
			dataType: "JSON",
			cache: cache
		}).done(function(json) {
			if (json) {
				json.rows.reverse();
				activity.view = new google.visualization.DataView(new google.visualization.DataTable(json));
				activity.view.setColumns(activity.columns);
				activity.graph.draw(activity.view, activity.options);
			}
		});
	};

	this.selectHandler = function() {
		var selections = activity.graph.getSelection();

		if (selections[0] && selections[0].row == null) {
			var c = selections[0].column;

			if (activity.columns[c].sourceColumn) {
				//activity.columns[c].calc = function() { return null };
				activity.columns[c].label = activity.columns[c].title + " (off)";
				delete activity.columns[c].sourceColumn;
			} else {
				activity.columns[c].sourceColumn = activity.columns[c].column;
				activity.columns[c].label = activity.columns[c].title;
				//delete activity.columns[c].calc;
			}

			activity.view.setColumns(activity.columns);
			activity.options.animation.duration = 0;
			activity.graph.draw(activity.view, activity.options);
			activity.options.animation.duration = 500;
		}
	}

	this.init = function() {
		activity.graph = new google.visualization.AreaChart(document.getElementById("activityGraph"));
		activity.options = {
			isStacked: false,
			backgroundColor: "transparent",
			hAxis: {textStyle: {color: "#999", fontName: "Verdana", fontSize: 10}, showTextEvery: 3},
			vAxis: {textStyle: {color: "#666", fontName: "Verdana", fontSize: 10}, viewWindowMode: "maximized", viewWindow: {min: 0}, maxValue: 5},
			gridlineColor: "#454545",
			pointSize: 2,
			lineWidth: 1,
			chartArea: {left: "10%", top: "5%", width: "88%", height: "85%"},
			legend: {position: "in", textStyle: {color: "#CCC", fontName: "Verdana", fontSize: 8.5}},
			animation: {duration: 500, easing: "inAndout"},
			tooltip: {showColorCode: true},
			annotations: {style: "line", textStyle: {fontSize: 12, color: "#ccc"}, domain: 0},
			focusTarget: "category"
		}

		google.visualization.events.addListener(activity.graph, "select", activity.selectHandler);

		activity.getData(activity.span);
	}

	this.time = function(span) {
		switch(span) {
			case 24:
				this.options.hAxis.showTextEvery = 3;
				break;
			case 48:
				this.options.hAxis.showTextEvery = 6;
				break;
			case 168:
				this.options.hAxis.showTextEvery = 24;
				break;
		}

		this.span = span;
		this.getData(span);
	}

	this.redraw = function() {
		this.graph.draw(this.view, this.options);
	}

	this.refresh = function(cache) {
		this.getData(this.span, cache);
	}

	google.charts.setOnLoadCallback(this.init);
}

var CKConfig = {
	skin: "custom",
	height: 100,
	allowedContent: true,
	extraPlugins: "toolbarswitch,autogrow,autolink",
	enterMode: CKEDITOR.ENTER_BR,
	removeDialogTabs: 'link:advanced',
	autoGrow_onStartup: true,
	autoGrow_minHeight: 100,
	toolbar_minToolbar: [
		{name: "basicstyles", items: ["Bold", "Italic", "Underline", "Strike"]},
		{name: "paragraph", items: ["BulletedList", "Outdent", "Indent"]},
		{name: "links", items: ["Link"]},
		{name: "colors", items: ["TextColor", "BGColor"]},
		{name: "styles", items: ["FontSize"]},
		{name: "tools", items: ["Toolbarswitch"]}
	],
	toolbar_maxToolbar: [
		{name: "basicstyles", items: ["Bold", "Italic", "Underline", "Strike", "Subscript", "Superscript"]},
		{name: "paragraph", items: ["NumberedList", "BulletedList", "Outdent", "Indent"]},
		{name: "links", items: ["Link"]},
		{name: "colors", items: ["TextColor", "BGColor"]},
		{name: "styles", items: ["FontSize", "Font"]},
		{name: "tools", items: ["Source", "Toolbarswitch"]}
	],
	toolbar: "minToolbar",
	smallToolbar: "minToolbar",
	maximizedToolbar: "maxToolbar",
	fontSize_style: {
	    element:        'span',
	    styles:         { 'font-size': '#(size)' },
	    overrides:      [ { element :'font', attributes: { 'size': null } } ]
	}
}

CKEDITOR.on("instanceLoaded", function(cke) {
	cke.editor.on("contentDom", function() {
		cke.editor.on("key", function(e) {
			if (e.data.keyCode == 27) {
				// escape key cancels
				$(cke.editor.element.$).closest(".comment").find(".commentCancel").click();
				return false;
			} else if (e.data.domEvent.$.altKey && e.data.domEvent.$.keyCode == 83) {
				// alt+s saves
				$(cke.editor.element.$).closest(".comment").find(".commentSave").click();
				return false;
			}
		});
	});

	$(".cke_combo__font a")
		.removeClass("cke_combo_button")
		.addClass("cke_button cke_button_off")
		.html('<span class="cke_button_icon">&nbsp;</span>')

	$(".cke_combo__fontsize a")
		.removeClass("cke_combo_button")
		.addClass("cke_button cke_button_off")
		.html('<span class="cke_button_icon">&nbsp;</span>')
});

CKEDITOR.on("instanceReady", function(cke) {
	// ensure focus on init
	cke.editor.focus();

	var s = cke.editor.getSelection(); // getting selection
	var selected_ranges = s.getRanges(); // getting ranges
	var node = selected_ranges[0].startContainer; // selecting the starting node
	var parents = node.getParents(true);

	node = parents[parents.length - 2].getFirst();

	if (!node) return false;

	while (true) {
		var x = node.getNext();
		if (x == null) {
			break;
		}
		node = x;
	}

	s.selectElement(node);
	selected_ranges = s.getRanges();
	selected_ranges[0].collapse(false);  //  false collapses the range to the end of the selected node, true before the node.
	s.selectRanges(selected_ranges);  // putting the current selection there
});

CKEDITOR.on("dialogDefinition", function(ev) {
	if (ev.data.name == 'link') {
		ev.data.definition.getContents('target').get('linkTargetType')['default'] = '_blank';
	}
});

$("body").on("dblclick", ".comment", function(e) {
	e.preventDefault();
	document.getSelection().removeAllRanges();
	$(this).find(".commentEdit").click();
})

$("body").on("click", ".commentEdit", function(e) {
	e.preventDefault();

	// Prevent multiple editors
	if ($(".cke").length) return false;

	var $comment = $(this).closest(".comment");

	$comment.find(".commentToolbar").hide();

	CKEDITOR.replace($comment.find(".commentBody").attr("id"), CKConfig).on("instanceReady", function() {
		$comment.find(".commentStatus").html("");
		$comment.find(".commentFooter").show();
		$comment.find(".commentFooter .commentControls").show();
	});

	tripwire.activity.editComment = $comment.data("id");
	tripwire.refresh('refresh');
});

$("body").on("click", ".commentSave, .commentCancel", function(e) {
	e.preventDefault();
	var $this = $(this);
	if ($this.attr("disabled")) return false;

	var $comment = $this.closest(".comment");
	$this.attr("disabled", "true");

	if ($this.hasClass("commentSave")) {
		var data = {"mode": "save", "commentID": $comment.data("id"), "systemID": $comment.find(".commentSticky").hasClass("active") ? 0 : viewingSystemID, "comment": CKEDITOR.instances[$comment.find(".commentBody").attr("id")].getData()};

		$.ajax({
			url: "comments.php",
			type: "POST",
			data: data,
			dataType: "JSON"
		}).done(function(data) {
			if (data && data.result == true) {
				$comment.find(".commentModified").html("Edited by " + data.comment.modifiedByName + " at " + data.comment.modifiedDate);
				$comment.find(".commentCreated").html("Posted by " + data.comment.createdByName + " at " + data.comment.createdDate);
				Tooltips.attach($comment.find("[data-tooltip]"));

				CKEDITOR.instances[$comment.find(".commentBody").attr("id")].destroy(false);
				$comment.attr("data-id", data.comment.id);
				$comment.find(".commentToolbar").show();
				$comment.find(".commentFooter").hide();
				$this.removeAttr("disabled");
			}
		});
	} else {
		CKEDITOR.instances[$comment.find(".commentBody").attr("id")].destroy(true);

		if (!$comment.attr("data-id")) {
			$comment.remove();
		} else {
			$comment.find(".commentToolbar").show();
			$comment.find(".commentFooter").hide();
			$this.removeAttr("disabled");
		}
	}

	$comment.find(".commentStatus").html("");

	delete tripwire.activity.editComment;
	tripwire.refresh('refresh');
});

$("body").on("click", ".commentDelete", function(e) {
	e.preventDefault();
	var $comment = $(this).closest(".comment");

	// check if dialog is open
	if (!$("#dialog-deleteComment").hasClass("ui-dialog-content")) {
		$("#dialog-deleteComment").data("comment", $comment).dialog({
			resizable: false,
			minHeight: 0,
			position: {my: "center", at: "center", of: $("#notesWidget")},
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				Delete: function() {
					// Prevent duplicate submitting
					$("#dialog-deleteComment").parent().find(":button:contains('Delete')").button("disable");

					var $comment = $(this).data("comment");
					var data = {"mode": "delete", "commentID": $comment.data("id")};

					$.ajax({
						url: "comments.php",
						type: "POST",
						data: data,
						dataType: "JSON"
					}).done(function(data) {
						if (data && data.result == true) {
							$("#dialog-deleteComment").dialog("close");
							$comment.remove();
						}
					}).always(function() {
						$("#dialog-deleteComment").parent().find(":button:contains('Delete')").button("enable");
					});
				},
				Cancel: function() {
					$(this).dialog("close");
				}
			}
		});
	} else if (!$("#dialog-deleteComment").dialog("isOpen")) {
		$("#dialog-deleteComment").data("comment", $comment).dialog("open");
	}
});

$("body").on("click", "#add-comment", function(e) {
	e.preventDefault();

	// Prevent multiple editors
	if ($(".cke").length) return false;

	var $comment = $(".comment:last").clone();
	var commentID = $(".comment:visible:last .commentBody").attr("id") ? $(".comment:visible:last .commentBody").attr("id").replace("comment", "") + 1 : 0;
	$(".comment:last").before($comment);

	$comment.find(".commentBody").attr("id", "comment" + commentID);
	$comment.removeClass("hidden").find(".commentEdit").click();
});

$("body").on("click", ".commentSticky", function(e) {
	e.preventDefault();
	var $comment = $(this).closest(".comment");

	var data = {"mode": "sticky", "commentID": $comment.data("id"), "systemID": $comment.find(".commentSticky").hasClass("active") ? viewingSystemID : 0};

	$.ajax({
		url: "comments.php",
		type: "POST",
		data: data,
		dataType: "JSON"
	}).done(function(data) {
		if (data && data.result == true) {
			$comment.find(".commentSticky").hasClass("active") ? $comment.find(".commentSticky").removeClass("active") : $comment.find(".commentSticky").addClass("active");
		}
	});
});

$("#admin").click(function(e) {
	e.preventDefault();

	if ($(this).hasClass("disabled")) {
		return false;
	}

	if (!$("#dialog-admin").hasClass("ui-dialog-content")) {
		var refreshTimer = null;
		var $total = null;
		var $ajax = null;

		function refreshWindow() {
			if ($ajax) $ajax.abort();
			$total.html("Total: " + $("#dialog-admin .window .hasFocus table tr[data-id]").length);

			$ajax = $.ajax({
				url: "admin.php",
				type: "POST",
				data: {mode: $("#dialog-admin .menu .active").attr("data-window")},
				dataType: "JSON"
			}).done(function(data) {
				if (data && data.results) {
					var rows = data.results;
					var ids = [];

					for (var i = 0, l = rows.length; i < l; i++) {
						var $row = $("#dialog-admin .window .hasFocus tbody tr[data-id='"+ rows[i].id +"']");
						ids.push(rows[i].id);

						if ($row.length) {
							for (col in rows[i]) {
								var $col = $row.find("[data-col='"+col+"']");
								$col.html(($col.attr("data-format") == "number" ? numFormat(rows[i][col]) : rows[i][col]) || "&nbsp;");
							}
						} else {
							$row = $("#dialog-admin .window .hasFocus table tr.hidden").clone();
							$row.attr("data-id", rows[i].id);

							for (col in rows[i]) {
								var $col = $row.find("[data-col='"+col+"']");
								$col.html(($col.attr("data-format") == "number" ? numFormat(rows[i][col]) : rows[i][col]) || "&nbsp;");
							}

							$row.removeClass("hidden");

							$("#dialog-admin .window .hasFocus tbody").append($row);
						}
					}

					$("#dialog-admin .window .hasFocus table tr[data-id]").each(function() {
						if ($.inArray($(this).data("id").toString(), ids) == -1) {
							$(this).remove();
						}
					});

					$("#dialog-admin .window .hasFocus table").trigger("update", [true]);
				} else {
					$("#dialog-admin .window .hasFocus table tr[data-id]").remove();
				}

				$total.html("Total: " + $("#dialog-admin .window .hasFocus table tr[data-id]").length);
			});

			if ($("#dialog-admin").dialog("isOpen") && $("#dialog-admin .menu .active").attr("data-refresh")) {
				refreshTimer = setTimeout(refreshWindow, $("#dialog-admin .menu .active").attr("data-refresh"));
			}
		}

		$("#dialog-admin").dialog({
			autoOpen: true,
			modal: true,
			height: 350,
			width: 800,
			buttons: {
				Close: function() {
					$(this).dialog("close");
				}
			},
			create: function() {
				// menu toggle
				$("#dialog-admin").on("click", ".menu li", function(e) {
					e.preventDefault();
					$menuItem = $(this);
					clearTimeout(refreshTimer);

					$("#dialog-admin .menu .active").removeClass("active");
					$menuItem.addClass("active");
					$("div.ui-dialog[aria-describedby='dialog-admin'] .ui-dialog-traypane").html("");

					$("#dialog-admin .window [data-window]").removeClass("hasFocus").hide();
					$("#dialog-admin .window [data-window='"+ $menuItem.data("window") +"']").addClass("hasFocus").show();

					refreshWindow();
				});

				$("#dialog-admin [data-sortable='true']").tablesorter({
					sortReset: true,
					widgets: ['saveSort'],
					sortList: [[0,0]]
				});

				// dialog bottom tray
				$($(this)[0].parentElement).find(".ui-dialog-buttonpane").append("<div class='ui-dialog-traypane'></div>");
				$total = $("div.ui-dialog[aria-describedby='dialog-admin'] .ui-dialog-traypane");
			},
			open: function() {
				$menuItem = $("#dialog-admin .menu li.active");
				refreshWindow();
			},
			close: function() {
				clearTimeout(refreshTimer);
			}
		});
	} else if (!$("#dialog-admin").dialog("isOpen")) {
		$("#dialog-admin").dialog("open");
	}
});

// Dialog effects
$("#wrapper").addClass("transition");

$(document).on("dialogopen", ".ui-dialog", function (event, ui) {
	// Add additional full screen overlay for 2nd level dialog
	if ($(".ui-dialog:visible").length == 2 && $(this).hasClass("dialog-modal"))
		$("body").append($("<div id='overlay' class='overlay' />").css("z-index", $(this).css("z-index") - 1));
	else if ($("#overlay"))
		$("#overlay").css("z-index", $(this).css("z-index") - 1);

	if (!$(this).hasClass("dialog-noeffect"))
		$("#wrapper").addClass("blur");
});

$(document).on("dialogclose", ".ui-dialog", function (event, ui) {
	if (!$(".ui-dialog").is(":visible"))
		$("#wrapper").removeClass("blur");

	if ($(".ui-dialog:visible").length == 1)
		$("#overlay").remove();
	else if ($("#overlay"))
		$("#overlay").css("z-index", $(this).css("z-index") - 2);

	//if ($(".ui-dialog:visible").length == 0 && options.buttons.follow && viewingSystemID != tripwire.client.EVE.systemID)
	//	window.location = "?system="+tripwire.client.EVE.systemName;
});

// Signature overwrite
$(document).on("click", "#overwrite", function() {
	var payload = {"signatures": {"remove": []}, "systemID": viewingSystemID};
	var undo = [];

	var signature = tripwire.client.signatures[$(this).data("id")];
	if (signature.type != "wormhole") {
		undo.push(signature);
		payload.signatures.remove.push(signature.id);
	} else {
		var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
		undo.push({"wormhole": wormhole, "signatures": [tripwire.client.signatures[wormhole.initialID], tripwire.client.signatures[wormhole.secondaryID]]});
		payload.signatures.remove.push(wormhole);
	}

	$("#overwrite").attr("disable", true);

	var success = function(data) {
		if (data.resultSet && data.resultSet[0].result == true) {
			ValidationTooltips.close();

			$("#undo").removeClass("disabled");
			if (viewingSystemID in tripwire.signatures.undo) {
				tripwire.signatures.undo[viewingSystemID].push({action: "remove", signatures: undo});
			} else {
				tripwire.signatures.undo[viewingSystemID] = [{action: "remove", signatures: undo}];
			}

			sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));

			if ($("#dialog-signature").parent().find(":button:contains('Save')")) {
				$("#dialog-signature").parent().find(":button:contains('Save')").click();
			} else {
				$("#dialog-signature").parent().find(":button:contains('Add')").click();
			}
		}
	}

	var always = function() {
		$("#overwrite").removeAttr("disable");
	}

	tripwire.refresh('refresh', payload, success, always);
});

$(".options").click(function(e) {
	e.preventDefault();

	if ($(this).hasClass("disabled"))
		return false;

	$("#dialog-options").dialog({
		autoOpen: false,
		width: 450,
		minHeight: 400,
		modal: true,
		buttons: {
			Save: function() {
				// Options
				var data = {mode: "set", options: JSON.stringify(options)};
				var maskChange = false;

				$("#dialog-options").parent().find(".ui-dialog-buttonpane button:contains('Save')").attr("disabled", true).addClass("ui-state-disabled");

				options.chain.typeFormat = $("#dialog-options #typeFormat").val();
				options.chain.classFormat = $("#dialog-options #classFormat").val();
				
				options.chain.sigNameLocation = $("#dialog-options #chainSigNameLocation").val();
				options.chain.routingLimit = 1 * $("#dialog-options #chainRoutingLimit").val();
				options.chain.routeSecurity = $("#dialog-options #chainRouteSecurity").val();
				options.chain.routeIgnore.enabled = $("#dialog-options #route-ignore-enabled").prop('checked');
				options.chain.routeIgnore.systems = $("#dialog-options #route-ignore").val().split(",").map(x => x.trim());

				options.chain.gridlines = JSON.parse($("#dialog-options input[name=gridlines]:checked").val());

				options.chain["node-reference"] = $("#dialog-options input[name=node-reference]:checked").val();
				
				options.chain.renderer = $("#dialog-options #renderer").val();

				options.signatures.editType = $("#dialog-options #editType").val();

				options.signatures.pasteLife = $("#dialog-options #pasteLife").val();

				options.signatures.copySeparator = $("#dialog-options #copySeparator").val();

				options.background = $("#dialog-options #background-image").val();

				options.uiscale = $("#dialog-options #uiscale-slider").slider("value");

				if (options.masks.active != $("#dialog-options input[name='mask']:checked").val()) {
					maskChange = true;
				}

				options.masks.active = $("#dialog-options input[name='mask']:checked").val();

				options.apply();
				options.save() // Performs AJAX
					.done(function() {
						if (maskChange) {
							// Reset signatures
							$("#sigTable span[data-age]").countdown("destroy");
							$("#sigTable tbody").empty()
							$("#signature-count").html(0);
							tripwire.signatures.list = {};
							tripwire.client.signatures = [];

							tripwire.refresh('change');
						}
					});


				$("#dialog-options").dialog("close");
				$("#dialog-options").parent().find(".ui-dialog-buttonpane button:contains('Save')").attr("disabled", false).removeClass("ui-state-disabled");

				// toggle mask admin icon
				$("#dialog-options input[name='mask']:checked").data("admin") ? $("#admin").removeClass("disabled") : $("#admin").addClass("disabled");
			},
			Reset: function() {
				$("#dialog-confirm #msg").html("Settings will be reset to defaults temporarily.<br/><br/><p><em>Save settings to make changes permanent.</em></p>");
				$("#dialog-confirm").dialog("option", {
					buttons: {
						Reset: function() {
							options.reset();
							options.apply();

							$("#dialog-options").dialog("close");
							$(this).dialog("close");
						},
						Cancel: function() {
							$(this).dialog("close");
						}
					}
				}).dialog("open");
			},
			Close: function() {
				$(this).dialog("close");
			}
		},
		open: function() {
			// Get user stats data
			$.ajax({
				url: "user_stats.php",
				type: "POST",
				dataType: "JSON"
			}).done(function(data) {
				for (i in data.stats) {
					for (x in data.stats[i]) {
						$("#optionsAccordion #"+ x).text(data.stats[i][x]);
					}
				}

				$("#optionsAccordion #systems_visited").text(data.system_visits);
				$("#optionsAccordion #logins").text(data.account.logins);
				$("#optionsAccordion #lastLogin").text(data.account.lastLogin);
				$("#optionsAccordion #username").text(data.username);
			});

			// Get masks
			$.ajax({
				url: "masks.php",
				type: "POST",
				dataType: "JSON"
			}).done(function(response) {
				if (response && response.masks) {
					$("#dialog-options #masks #default").html("");
					$("#dialog-options #masks #personal").html("");
					$("#dialog-options #masks #corporate").html("");

					for (var x in response.masks) {
						var mask = response.masks[x];
						var node = $(''
							+ '<input type="radio" name="mask" id="mask'+x+'" value="'+mask.mask+'" class="selector" data-owner="'+mask.owner+'" data-admin="'+mask.admin+'" />'
							+ '<label for="mask'+x+'"><img src="'+mask.img+'" />'
							+  (mask.optional ? '<i class="closeIcon" onclick="return false;" data-icon="red-giant"><i data-icon="times"></i></i>' : '')
							+ '<span class="selector_label">'+mask.label+'</span></label>');

						$("#dialog-options #masks #"+mask.type).append(node);
					}

					var node = $(''
						+ '<input type="checkbox" name="find" id="findp" value="personal" class="selector" disabled="disabled" />'
						+ '<label for="findp"><i data-icon="search" style="font-size: 3em; margin-left: 16px; margin-top: 16px; display: block;"></i></label>');
					$("#dialog-options #masks #personal").append(node);

					if (init.admin == "1") {
						var node = $(''
							+ '<input type="checkbox" name="find" id="findc" value="corporate" class="selector" disabled="disabled" />'
							+ '<label for="findc"><i data-icon="search" style="font-size: 3em; margin-left: 16px; margin-top: 16px; display: block;"></i></label>');
						$("#dialog-options #masks #corporate").append(node);
					}

					$("#dialog-options input[name='mask']").filter("[value='"+response.masks[response.active].mask+"']").attr("checked", true).trigger("change");

					// toggle mask admin icon
					response.masks[response.active].admin ? $("#admin").removeClass("disabled") : $("#admin").addClass("disabled");
				}
			});

			$("#dialog-options #editType").val(options.signatures.editType);
			$("#dialog-options #pasteLife").val(options.signatures.pasteLife);
			$("#dialog-options #copySeparator").val(options.signatures.copySeparator);
			$("#dialog-options #typeFormat").val(options.chain.typeFormat);
			$("#dialog-options #chainRoutingLimit").val(options.chain.routingLimit);
			$("#dialog-options #chainSigNameLocation").val(options.chain.sigNameLocation);
			$("#dialog-options #chainRouteSecurity").val(options.chain.routeSecurity);
			$("#dialog-options #route-ignore-enabled").prop('checked', options.chain.routeIgnore.enabled);
			$("#dialog-options #route-ignore").val(options.chain.routeIgnore.systems.join(','));
			$("#dialog-options #renderer").val(options.chain.renderer);
			$("#dialog-options #classFormat").val(options.chain.classFormat);
			$("#dialog-options input[name='node-reference'][value='"+options.chain["node-reference"]+"']").prop("checked", true);
			$("#dialog-options input[name='gridlines'][value='"+options.chain.gridlines+"']").prop("checked", true);
			$("#dialog-options #background-image").val(options.background);
		},
		create: function() {
			$("#optionsAccordion").accordion({heightStyle: "content", collapsible: true, active: false});

			$("#uiscale-slider").slider({
				min: 0.7,
				max: 1.4,
				step: 0.05,
				value: options.uiscale || 1.0,
				change: function(e, ui) {
					$("body").css("zoom", ui.value);
				},
				slide: function(e, ui) {
					$("label[for='uiscale-slider']").html(ui.value);
				}
			});

			$("label[for='uiscale-slider']").html($("#uiscale-slider").slider("value"));

			$("#dialog-pwChange").dialog({
				autoOpen: false,
				resizable: false,
				minHeight: 0,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Save: function() {
						$("#pwForm").submit();
					},
					Cancel: function() {
						$(this).dialog("close");
					}
				},
				close: function() {
					$("#pwForm input[name='password'], #pwForm input[name='confirm']").val("");
					$("#pwError").text("").hide();
				}
			});

			$("#pwChange").click(function() {
				$("#dialog-pwChange").dialog("open");
			});

			$("#pwForm").submit(function(e) {
				e.preventDefault();

				$("#pwError").text("").hide();

				$.ajax({
					url: "options.php",
					type: "POST",
					data: $(this).serialize(),
					dataType: "JSON"
				}).done(function(response) {
					if (response && response.result) {
						$("#dialog-msg #msg").text("Password changed");
						$("#dialog-msg").dialog("open");

						$("#dialog-pwChange").dialog("close");
					} else if (response && response.error) {
						$("#pwError").text(response.error).show("slide", {direction: "up"});
					} else {
						$("#pwError").text("Unknown error").show("slide", {direction: "up"});
					}
				});
			});

			$("#dialog-usernameChange").dialog({
				autoOpen: false,
				resizable: false,
				minHeight: 0,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Save: function() {
						$("#usernameForm").submit();
					},
					Cancel: function() {
						$(this).dialog("close");
					}
				},
				open: function() {
					$("#usernameForm #username").html($("#dialog-options #username").html());
				},
				close: function() {
					$("#usernameForm [name='username']").val("");
					$("#usernameError").text("").hide();
				}
			});

			$("#usernameChange").click(function() {
				$("#dialog-usernameChange").dialog("open");
			});

			$("#usernameForm").submit(function(e) {
				e.preventDefault();

				$("#usernameError").text("").hide();

				$.ajax({
					url: "options.php",
					type: "POST",
					data: $(this).serialize(),
					dataType: "JSON"
				}).done(function(response) {
					if (response && response.result) {
						$("#dialog-msg #msg").text("Username changed");
						$("#dialog-msg").dialog("open");

						$("#dialog-options #username").html(response.result);

						$("#dialog-usernameChange").dialog("close");
					} else if (response && response.error) {
						$("#usernameError").text(response.error).show("slide", {direction: "up"});
					} else {
						$("#usernameError").text("Unknown error").show("slide", {direction: "up"});
					}
				});
			});

			// Mask selections
			$("#masks").on("change", "input.selector:checked", function() {
				if ($(this).data("owner")) {
					$("#maskControls #edit").removeAttr("disabled");
					$("#maskControls #delete").removeAttr("disabled");
				} else {
					$("#maskControls #edit").attr("disabled", "disabled");
					$("#maskControls #delete").attr("disabled", "disabled");
				}

				if ($(this).val() != 0.0 && $(this).val().split(".")[1] == 0) {
					$("#dialog-options #leave").removeAttr("disabled");
				} else {
					$("#dialog-options #leave").attr("disabled", "disabled");
				}
			});

			// Mask join
			$("#dialog-joinMask").dialog({
				autoOpen: false,
				resizable: false,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Add: function() {
						var mask = $("#dialog-joinMask #results input:checked");
						var label = $("#dialog-joinMask #results input:checked+label");

						$.ajax({
							url: "masks.php",
							type: "POST",
							data: {mask: mask.val(), mode: "join"},
							dataType: "JSON"
						}).done(function(response) {
							if (response && response.result) {
								label.css("width", "");
								label.find(".info").remove();
								label.append('<i class="closeIcon" onclick="return false;" data-icon="red-giant"><i data-icon="times"></i></i>');

								$("#dialog-options #masks #"+response.type+" input.selector:last").before(mask).before(label);
								$("#dialog-joinMask").dialog("close");
							}
						});
					},
					Cancel: function() {
						$(this).dialog("close");
					}
				},
				create: function() {
					$("#dialog-joinMask form").submit(function(e) {
						e.preventDefault();

						$("#dialog-joinMask #results").html("");
						$("#dialog-joinMask #loading").show();
						$("#dialog-joinMask input[type='submit']").attr("disabled", "disabled");

						$.ajax({
							url: "masks.php",
							type: "POST",
							data: $(this).serialize(),
							dataType: "JSON"
						}).then(function(response) {
							if (response && response.results && response.results.length) {
								return tripwire.esi.fullLookup(response.eveIDs)
									.done(function(results) {
										if (results) {
											for (var x in results) {
												var mask = response.results[x];
												var node = $(''
													+ '<input type="radio" name="mask" id="mask'+mask.mask+'" value="'+mask.mask+'" class="selector" data-owner="false" data-admin="'+mask.admin+'" />'
													+ '<label for="mask'+mask.mask+'" style="width: 100%; margin-left: -5px;">'
													+ '	<img src="'+mask.img+'" />'
													+ '	<span class="selector_label">'+mask.label+'</span>'
													+ '	<div class="info">'
													+ '		'+results[x].name + '<br/>'
													+ '		'+(results[x].category == "character" ? results[x].corporation.name +'<br/>' : null)
													+ '		'+(results[x].alliance ? results[x].alliance.name : '')+'<br/>'
													+ '	</div>'
													+ '</label>');

												$("#dialog-joinMask #results").append(node);
											}
										}
									});
							} else if (response && response.error) {
								$("#dialog-error #msg").text(response.error);
								$("#dialog-error").dialog("open");
							} else {
								$("#dialog-error #msg").text("Unknown error");
								$("#dialog-error").dialog("open");
							}
						}).then(function() {
							$("#dialog-joinMask #loading").hide();
							$("#dialog-joinMask input[type='submit']").removeAttr("disabled");
						});
					})
				},
				close: function() {
					$("#dialog-joinMask #results").html("");
					$("#dialog-joinMask input[name='name']").val("");
				}
			});

			$("#dialog-options #masks").on("click", "input[name='find']+label", function() {
				$("#dialog-joinMask input[name='find']").val($(this).prev().val());
				$("#dialog-joinMask").dialog("open");
			});

			// Mask leave
			$("#dialog-options #masks").on("click", ".closeIcon", function() {
				var mask = $(this).closest("input.selector+label").prev();

				$("#dialog-confirm #msg").text("Are you sure you want to remove this mask?");

				$("#dialog-confirm").dialog("option", {
					buttons: {
						Remove: function() {
							var send = {mode: "leave", mask: mask.val()};

							$.ajax({
								url: "masks.php",
								type: "POST",
								data: send,
								dataType: "JSON"
							}).done(function(response) {
								if (response && response.result) {
									mask.next().remove();
									mask.remove();

									$("#dialog-confirm").dialog("close");
								} else {
									$("#dialog-confirm").dialog("close");

									$("#dialog-error #msg").text("Unable to delete");
									$("#dialog-error").dialog("open");
								}
							});
						},
						Cancel: function() {
							$(this).dialog("close");
						}
					}
				}).dialog("open");
			});

			// Mask delete
			$("#maskControls #delete").click(function() {
				var mask = $("#masks input.selector:checked");

				$("#dialog-confirm #msg").text("Are you sure you want to delete this mask?");
				$("#dialog-confirm").dialog("option", {
					buttons: {
						Delete: function() {
							var send = {mode: "delete", mask: mask.val()};

							$.ajax({
								url: "masks.php",
								type: "POST",
								data: send,
								dataType: "JSON"
							}).done(function(response) {
								if (response && response.result) {
									mask.next().remove();
									mask.remove();

									$("#dialog-confirm").dialog("close");
								} else {
									$("#dialog-confirm").dialog("close");

									$("#dialog-error #msg").text("Unable to delete");
									$("#dialog-error").dialog("open");
								}
							});
						},
						Cancel: function() {
							$(this).dialog("close");
						}
					}
				}).dialog("open");
			});

			// User Create mask
			$("#dialog-createMask").dialog({
				autoOpen: false,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Create: function() {
						$("#dialog-createMask form").submit();
					},
					Cancel: function() {
						$(this).dialog("close");
					}
				},
				create: function() {
					$("#dialog-createMask #accessList").on("click", "#create_add+label", function() {
						$("#dialog-EVEsearch").dialog("open");
					});

					$("#dialog-createMask form").submit(function(e) {
						e.preventDefault();

						$.ajax({
							url: "masks.php",
							type: "POST",
							data: $(this).serialize(),
							dataType: "JSON"
						}).done(function(response) {
							if (response && response.result) {
								// Get masks
								$.ajax({
									url: "masks.php",
									type: "POST",
									dataType: "JSON"
								}).done(function(response) {
									if (response && response.masks) {
										$("#dialog-options #masks #default").html("");
										$("#dialog-options #masks #personal").html("");
										$("#dialog-options #masks #corporate").html("");

										for (var x in response.masks) {
											var mask = response.masks[x];
											var node = $(''
												+ '<input type="radio" name="mask" id="mask'+x+'" value="'+mask.mask+'" class="selector" data-owner="'+mask.owner+'" data-admin="'+mask.admin+'" />'
												+ '<label for="mask'+x+'"><img src="'+mask.img+'" />'
												+  (mask.optional ? '<i class="closeIcon" onclick="return false;" data-icon="red-giant"><i data-icon="times"></i></i>' : '')
												+ '<span class="selector_label">'+mask.label+'</span></label>');

											$("#dialog-options #masks #"+mask.type).append(node);
										}

										var node = $(''
											+ '<input type="checkbox" name="find" id="findp" value="personal" class="selector" disabled="disabled" />'
											+ '<label for="findp"><i data-icon="search" style="font-size: 3em; margin-left: 16px; margin-top: 16px; display: block;"></i></label>');
										$("#dialog-options #masks #personal").append(node);

										if (init.admin == "1") {
											var node = $(''
												+ '<input type="checkbox" name="find" id="findc" value="corporate" class="selector" disabled="disabled" />'
												+ '<label for="findc"><i data-icon="search" style="font-size: 3em; margin-left: 16px; margin-top: 16px; display: block;"></i></label>');
											$("#dialog-options #masks #corporate").append(node);
										}

										$("#dialog-options input[name='mask']").filter("[value='"+response.masks[response.active].mask+"']").attr("checked", true).trigger("change");

										// toggle mask admin icon
										response.masks[response.active].admin ? $("#admin").removeClass("disabled") : $("#admin").addClass("disabled");
									}
								});

								$("#dialog-createMask").dialog("close");
							} else if (response && response.error) {
								$("#dialog-error #msg").text(response.error);
								$("#dialog-error").dialog("open");
							} else {
								$("#dialog-error #msg").text("Unknown error");
								$("#dialog-error").dialog("open");
							}
						});
					});

					$("#dialog-createMask select").selectmenu({width: 100});
				},
				open: function() {
					$("#dialog-createMask input[name='name']").val("");
					$("#dialog-createMask #accessList :not(.static)").remove();
				}
			});

			$("#maskControls #create").click(function() {
				$("#dialog-createMask").dialog("open");
			});

			$("#dialog-createMask #accessList").on("click", ".maskRemove", function() {
				$(this).closest("input.selector+label").prev().remove();
				$(this).closest("label").remove();
			});

			$("#dialog-editMask").dialog({
				autoOpen: false,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Save: function() {
						$("#dialog-editMask form").submit();
					},
					Cancel: function() {
						$(this).dialog("close");
					}
				},
				create: function() {
					$("#dialog-editMask #accessList").on("click", ".maskRemove", function() {
						$(this).closest("input.selector+label").prev().attr("name", "deletes[]").hide();
						$(this).closest("label").hide();
					});

					$("#dialog-editMask #accessList").on("click", "#edit_add+label", function() {
						$("#dialog-EVEsearch").dialog("open");
					});

					$("#dialog-editMask form").submit(function(e) {
						e.preventDefault();

						$.ajax({
							url: "masks.php",
							type: "POST",
							data: $(this).serialize(),
							dataType: "JSON"
						}).done(function(response) {
							if (response && response.result) {
								$("#dialog-editMask").dialog("close");
							} else if (response && response.error) {
								$("#dialog-error #msg").text(response.error);
								$("#dialog-error").dialog("open");
							} else {
								$("#dialog-error #msg").text("Unknown error");
								$("#dialog-error").dialog("open");
							}
						});
					});
				},
				open: function() {
					var mask = $("#dialog-options input[name='mask']:checked").val();
					$("#dialog-editMask input[name='mask']").val(mask);
					$("#dialog-editMask #accessList label.static").hide();
					$("#dialog-editMask #loading").show();
					$("#dialog-editMask #name").text($("#dialog-options input[name='mask']:checked+label .selector_label").text());

					$.ajax({
						url: "masks.php",
						type: "POST",
						data: {mode: "edit", mask: mask},
						dataType: "JSON"
					}).then(function(response) {
						if (response && response.results && response.results.length) {
							return tripwire.esi.fullLookup(response.results)
								.done(function(results) {
									if (results) {
										for (var x in results) {
											if (results[x].category == "character") {
												var node = $(''
													+ '<input type="checkbox" checked="checked" onclick="return false" name="" id="edit_'+results[x].id+'_1373" value="'+results[x].id+'_1373" class="selector" />'
													+ '<label for="edit_'+results[x].id+'_1373">'
													+ '	<img src="https://image.eveonline.com/Character/'+results[x].id+'_64.jpg" />'
													+ '	<span class="selector_label">Character</span>'
													+ '	<div class="info">'
													+ '		'+results[x].name + '<br/>'
													+ '		'+results[x].corporation.name+'<br/>'
													+ '		'+(results[x].alliance ? results[x].alliance.name : '')+'<br/>'
													+ '		<input type="button" class="maskRemove" value="Remove" style="position: absolute; bottom: 3px; right: 3px;" />'
													+ '	</div>'
													+ '</label>');

												$("#dialog-editMask #accessList .static:first").before(node);
											} else if (results[x].category == "corporation") {
												var node = $(''
													+ '<input type="checkbox" checked="checked" onclick="return false" name="" id="edit_'+results[x].id+'_2" value="'+results[x].id+'_2" class="selector" />'
													+ '<label for="edit_'+results[x].id+'_2">'
													+ '	<img src="https://image.eveonline.com/Corporation/'+results[x].id+'_64.png" />'
													+ '	<span class="selector_label">Corporation</span>'
													+ '	<div class="info">'
													+ '		'+results[x].name+'<br/>'
													+ '		'+(results[x].alliance ? results[x].alliance.name : '')+'<br/>'
													+ '		<input type="button" class="maskRemove" value="Remove" style="position: absolute; bottom: 3px; right: 3px;" />'
													+ '	</div>'
													+ '</label>');

												$("#dialog-editMask #accessList .static:first").before(node);
											}
										}
									}
								});
						}
					}).then(function(response) {
						$("#dialog-editMask #accessList label.static").show();
						$("#dialog-editMask #loading").hide();
					});
				},
				close: function() {
					$("#dialog-editMask #accessList :not(.static)").remove();
				}
			});

			$("#maskControls #edit").click(function() {
				$("#dialog-editMask").dialog("open");
			});

			// EVE search dialog
			$("#dialog-EVEsearch").dialog({
				autoOpen: false,
				dialogClass: "ui-dialog-shadow dialog-noeffect dialog-modal",
				buttons: {
					Add: function() {
						if ($("#accessList input[value='"+$("#EVESearchResults input").val()+"']").length) {
							$("#dialog-error #msg").text("Already has access");
							$("#dialog-error").dialog("open");
							return false;
						}

						$("#EVESearchResults .info").append('<input type="button" class="maskRemove" value="Remove" style="position: absolute; bottom: 3px; right: 3px;" />');
						$("#EVESearchResults input:checked").attr("checked", "checked");
						$("#EVESearchResults input:checked").attr("onclick", "return false");

						var nodes = $("#EVESearchResults .maskNode:has(input:checked)");

						if ($("#dialog-createMask").dialog("isOpen"))
							$("#dialog-createMask #accessList .static:first").before(nodes);
						else if ($("#dialog-editMask").dialog("isOpen"))
							$("#dialog-editMask #accessList .static:first").before(nodes);

						$(this).dialog("close");
					},
					Close: function() {
						$(this).dialog("close");
					}
				},
				create: function() {
					$("#EVEsearch").submit(function(e) {
						e.preventDefault();

						if ($("#EVEsearch input[name='name']").val() == "") {
							return false;
						}

						$("#EVESearchResults, #searchCount").html("");
						$("#EVEsearch #searchSpinner").show();
						$("#EVEsearch input[type='submit']").attr("disabled", "disabled");
						$("#dialog-EVEsearch").parent().find(".ui-dialog-buttonpane button:contains('Add')").attr("disabled", true).addClass("ui-state-disabled");

						tripwire.esi.search($("#EVEsearch input[name='name']").val(), $("#EVEsearch input[name='category']:checked").val(), $("#EVEsearch input[name='exact']")[0].checked)
							.done(function(results) {
								if (results && (results.character || results.corporation)) {
									// limit results
									results = $.merge(results.character || [], results.corporation || []);
									total = results.length;
									results = results.slice(0, 10);
									return tripwire.esi.fullLookup(results)
										.done(function(results) {
											$("#EVEsearch #searchCount").html("Found: "+total+"<br/>Showing: "+(total<10?total:10));
											if (results) {
												for (var x in results) {
													if (results[x].category == "character") {
														var node = $(''
															+ '<div class="maskNode"><input type="checkbox" name="adds[]" id="find_'+results[x].id+'_1373" value="'+results[x].id+'_1373" class="selector" />'
															+ '<label for="find_'+results[x].id+'_1373">'
															+ '	<img src="https://image.eveonline.com/Character/'+results[x].id+'_64.jpg" />'
															+ '	<span class="selector_label">Character</span>'
															+ '	<div class="info">'
															+ '		'+results[x].name + '<br/>'
															+ '		'+results[x].corporation.name+'<br/>'
															+ '		'+(results[x].alliance ? results[x].alliance.name : '')+'<br/>'
															+ '	</div>'
															+ '</label></div>');

														$("#EVESearchResults").append(node);
													} else if (results[x].category == "corporation") {
														var node = $(''
															+ '<div class="maskNode"><input type="checkbox" name="adds[]" id="find_'+results[x].id+'_2" value="'+results[x].id+'_2" class="selector" />'
															+ '<label for="find_'+results[x].id+'_2">'
															+ '	<img src="https://image.eveonline.com/Corporation/'+results[x].id+'_64.png" />'
															+ '	<span class="selector_label">Corporation</span>'
															+ '	<div class="info">'
															+ '		'+results[x].name+'<br/>'
															+ '		'+(results[x].alliance ? results[x].alliance.name : '')+'<br/>'
															+ '	</div>'
															+ '</label></div>');

														$("#EVESearchResults").append(node);
													}
												}
											}
										}).always(function() {
											$("#EVEsearch #searchSpinner").hide();
											$("#EVEsearch input[type='submit']").removeAttr("disabled");
											$("#dialog-EVEsearch").parent().find(".ui-dialog-buttonpane button:contains('Add')").removeAttr("disabled").removeClass("ui-state-disabled");
										});
								} else {
									$("#dialog-error #msg").text("No Results");
									$("#dialog-error").dialog("open");

									$("#EVEsearch #searchSpinner").hide();
									$("#EVEsearch input[type='submit']").removeAttr("disabled");
									$("#dialog-EVEsearch").parent().find(".ui-dialog-buttonpane button:contains('Add')").removeAttr("disabled").removeClass("ui-state-disabled");
								}
							});
					});
				},
				close: function() {
					$("#EVEsearch input[name='name']").val("");
					$("#EVESearchResults, #searchCount").html("");
				}
			});
		}
	});

	$("#dialog-options").dialog("open");
});

		$("#dialog-ping").dialog({
			autoOpen: false,
			height: "auto",
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				Send: function() {
					var payload = {systemName: this.systemName, systemText: this.systemText, message: $('#ping-text').val() };
					const _this = this;
					$.ajax({
						url: "ping.php",
						type: "POST",
						data: payload,
						dataType: "JSON"
					}).done(function(data) {	$(_this).dialog("close"); })
					.error(function(data) { alert((data && data.error) ? data.error : data); });
				},
				Cancel: function() {
					$(this).dialog("close");
				},
			},
			open: function() {
				const wormholeID = $(this).data("id");
				const systemID = $(this).data("systemID");
				const wormhole = tripwire.client.wormholes[wormholeID];
				const fromSignature = wormhole ? tripwire.client.signatures[wormhole.initialID] : { name: null};
				
				this.systemName = tripwire.systems[systemID].name;
				this.systemText = this.systemName + (fromSignature.name !== null && fromSignature.name.length ? ' (' + fromSignature.name + ')' : '');
				
				$("#dialog-ping").dialog("option", "title", "Ping about "+this.systemText);
				$('#ping-text').val('');
				$('#ping-text').focus();
			}
		});
$("#signaturesWidget").on("click", "#delete-signature", function(e) {
	e.preventDefault();

	if ($(this).closest("tr").attr("disabled")) {
		return false;
	} else if ($("#sigTable tr.selected").length == 0) {
		return false;
	} else if ($("#dialog-sigEdit").hasClass("ui-dialog-content") && $("#dialog-sigEdit").dialog("isOpen")) {
		$("#dialog-sigEdit").parent().effect("shake", 300);
		return false;
	}

	// check if dialog is open
	if (!$("#dialog-deleteSig").hasClass("ui-dialog-content")) {
		$("#dialog-deleteSig").dialog({
			resizable: false,
			minHeight: 0,
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			buttons: {
				Delete: function() {
					// Prevent duplicate submitting
					$("#dialog-deleteSig").parent().find(":button:contains('Delete')").button("disable");
					var payload = {"signatures": {"remove": []}, "systemID": viewingSystemID};
					var undo = [];

					var signatures = $.map($("#sigTable tr.selected"), function(n) {
						var signature = tripwire.client.signatures[$(n).data("id")];
						if (signature.type != "wormhole") {
							undo.push(signature);
							return signature.id;
						} else {
							var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
							undo.push({"wormhole": wormhole, "signatures": [tripwire.client.signatures[wormhole.initialID], tripwire.client.signatures[wormhole.secondaryID]]});
							return wormhole;
						}
					});
					payload.signatures.remove = signatures;

					var success = function(data) {
						if (data.resultSet && data.resultSet[0].result == true) {
							$("#dialog-deleteSig").dialog("close");

							$("#undo").removeClass("disabled");
							if (viewingSystemID in tripwire.signatures.undo) {
								tripwire.signatures.undo[viewingSystemID].push({action: "remove", signatures: undo});
							} else {
								tripwire.signatures.undo[viewingSystemID] = [{action: "remove", signatures: undo}];
							}

							sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
						}
					}

					var always = function(data) {
						$("#dialog-deleteSig").parent().find(":button:contains('Delete')").button("enable");
					}

					tripwire.refresh('refresh', payload, success, always);
				},
				Cancel: function() {
					$(this).dialog("close");
				}
			},
			close: function() {
				$("#sigTable tr.selected").removeClass("selected");
				//$("#sigTable .sigDelete").removeClass("invisible");
			}
		});
	} else if (!$("#dialog-deleteSig").dialog("isOpen")) {
		$("#dialog-deleteSig").dialog("open");
	}
});

$("#sigTable tbody").on("dblclick", "tr", {mode: "update", source:"sig-row"}, openSignatureDialog);
$("#edit-signature").on("click", {mode: "update", source:"edit-sig"}, openSignatureDialog);
$("#add-signature").click({mode: "add"}, openSignatureDialog);

const sigDialogVM = {};
function openSignatureDialog(e) {
	if(e.preventDefault) { e.preventDefault(); }	// Allow calls with fake event-like objects too
	sigDialogVM.mode = e.data.mode;
	
	switch(sigDialogVM.mode) {
		case 'update':
			if (e.data.source == "sig-row") {
				$("#sigTable tr.selected").removeClass("selected");
				$(this).closest("tr").addClass("selected");
				sigDialogVM.sigId = $(this).data('id');
			} else if (e.data.source == "edit-sig") {
				var elements = $("#sigTable tbody tr.selected");
				if (elements.length !== 1) {
					return false;
				} else {
					sigDialogVM.sigId = $(elements[0]).data('id');
				}
			} else { sigDialogVM.sigId = e.data.signature; }
			break;
		default: delete sigDialogVM.sigId;
	}
	
	sigDialogVM.viewingSystemID = ( sigDialogVM.sigID ) ? tripwire.client.signatures[sigDialogVM.sigId].systemID : viewingSystemID;
	sigDialogVM.viewingSystem = tripwire.systems[sigDialogVM.viewingSystemID];
	
	if (!$("#dialog-signature").hasClass("ui-dialog-content")) {
		$("#dialog-signature").dialog({
			autoOpen: true,
			resizable: false,
			dialogClass: "dialog-noeffect ui-dialog-shadow",
			position: {my: "center", at: "center", of: $("#signaturesWidget")},
			buttons: {
				Save: function() {
					$("#form-signature").submit();
				},
				Add: function() {
					$("#form-signature").submit();
				},
				Cancel: function() {
					$(this).dialog("close");
				}
			},
			create: function() {
				var aSigWormholes = $.map(tripwire.wormholes, function(item, index) { return index;});
				aSigWormholes.splice(26, 0, "K162");
				aSigWormholes.push("GATE");
				aSigWormholes.push("SML");
				aSigWormholes.push("MED");
				aSigWormholes.push("LRG");
				aSigWormholes.push("XLG");

				$("#dialog-signature [name='signatureType'], #dialog-signature [name='signatureLife']").selectmenu({width: 100});
				$("#dialog-signature [name='wormholeLife'], #dialog-signature [name='wormholeMass']").selectmenu({width: 80});
				$("#dialog-signature [data-autocomplete='sigSystems']").inlinecomplete({source: tripwire.aSigSystems, maxSize: 10, delay: 0});
				$("#dialog-signature [data-autocomplete='sigType']").inlinecomplete({source: aSigWormholes, maxSize: 10, delay: 0});

				$("#dialog-signature #durationPicker").durationPicker();
				$("#dialog-signature #durationPicker").on("change", function() {
					// prevent negative values
					if (this.value < 0) {
						this.value = 0;
						$(this).change();
					}
				});

				// Ensure first signature ID field only accepts letters
				$("#dialog-signature [name='signatureID_Alpha'], #dialog-signature [name='signatureID2_Alpha']").on("input", function() {
					while (!/^[a-zA-Z?]*$/g.test(this.value)) {
						this.value = this.value.substring(0, this.value.length -1);
					}
				});

				// Move to the numeric ID after filling out alpha ID
				$("#dialog-signature [name='signatureID_Alpha']").on("input", function() {
					if (this.value.length === 3) {
						$("#dialog-signature [name='signatureID_Numeric']").select();
					}
				});

				$("#dialog-signature [name='signatureID2_Alpha']").on("input", function() {
					if (this.value.length === 3) {
						$("#dialog-signature [name='signatureID2_Numeric']").select();
					}
				});

				// Ensure second signature ID field only accepts numbers
				$("#dialog-signature [name='signatureID_Numeric'], #dialog-signature [name='signatureID2_Numeric']").on("input", function() {
					while (!/^[0-9?]*$/g.test(this.value)) {
						this.value = this.value.substring(0, this.value.length -1);
					}
				});

				// Select value on click
				$("#dialog-signature .signatureID, #dialog-signature .wormholeType").on("click", function() {
					$(this).select();
				});

				// Auto fill opposite side wormhole w/ K162
				$("#dialog-signature .wormholeType").on("input, change", function() {
					if (this.value.length > 0 && $.inArray(this.value.toUpperCase(), aSigWormholes) != -1 && this.value.toUpperCase() != "K162") {
						$("#dialog-signature .wormholeType").not(this).val("K162");

						// Also auto calculate duration
						if (tripwire.wormholes[this.value.toUpperCase()]) {
							$("#dialog-signature #durationPicker").val(tripwire.wormholes[this.value.toUpperCase()].life.substring(0, 2) * 60 * 60).change();
						}
					} else if (this.value.toUpperCase() === "K162") {
						if ($.inArray($("#dialog-signature .wormholeType").not(this).val().toUpperCase(), aSigWormholes) === -1 || $("#dialog-signature .wormholeType").not(this).val().toUpperCase() === "K162") {
							$("#dialog-signature .wormholeType").not(this).val("????");
						}
					} else if (this.value == "????") {
						$("#dialog-signature .wormholeType").not(this).val("K162");
					}
				});

				// Toggle between wormhole and regular signatures
				$("#dialog-signature").on("selectmenuchange", "[name='signatureType']", function() {
					if (this.value == "wormhole") {
						$("#dialog-signature #site").slideUp(200, function() { $(this).hide(0); });
						$("#dialog-signature #wormhole").slideDown(200, function() { $(this).show(200); });
					} else {
						$("#dialog-signature #site").slideDown(200, function() { $(this).show(200); });
						$("#dialog-signature #wormhole").slideUp(200, function() { $(this).hide(0); });
					}

					ValidationTooltips.close();
				});

				$("#form-signature").submit(function(e) {
					e.preventDefault();
					var form = $(this).serializeObject();
					var valid = true;
					ValidationTooltips.close();

					// Validate full signature ID fields (blank | 3 characters)
					$.each($("#dialog-signature .signatureID:visible"), function() {
						if (this.value.length > 0 && this.value.length < 3) {
							ValidationTooltips.open({target: $(this)}).setContent("Must be 3 characters in length!");
							$(this).select();
							valid = false;
							return false;
						}
					});
					if (!valid) return false;

					// Validate full signature ID doesn't already exist in current system
					if (form.signatureID_Alpha.length === 3 && form.signatureID_Numeric.length === 3 && Object.find(tripwire.client.signatures, "signatureID", form.signatureID_Alpha + form.signatureID_Numeric, true) != false && Object.find(tripwire.client.signatures, "signatureID", form.signatureID_Alpha + form.signatureID_Numeric, true).id != $("#dialog-signature").data("signatureid")) {
						var existingSignature = Object.find(tripwire.client.signatures, "signatureID", form.signatureID_Alpha + form.signatureID_Numeric);
						ValidationTooltips.open({target: $("#dialog-signature .signatureID:first")}).setContent("Signature ID already exists! <input type='button' autofocus='true' id='overwrite' value='Overwrite' style='margin-bottom: -4px; margin-top: -4px; font-size: 0.8em;' data-id='"+ existingSignature.id +"' />");
						$("#overwrite").focus();
						valid = false;
						return false;
					}
					if (!valid) return false;

					// Validate wormhole types (blank | wormhole)
					$.each($("#dialog-signature .wormholeType:visible"), function() {
						if (this.value.length > 0 && $.inArray(this.value.toUpperCase(), aSigWormholes) == -1 && this.value != "????") {
							ValidationTooltips.open({target: $(this)}).setContent("Must be a valid wormhole type!");
							$(this).select();
							valid = false;
							return false;
						}
					});
					if (!valid) return false;

					// Validate leads to system (blank | system)
					$.each($("#dialog-signature .leadsTo:visible"), function() {
						if (this.value.length > 0 && tripwire.aSigSystems.findIndex((item) => this.value.toLowerCase() === item.toLowerCase()) == -1) {
							ValidationTooltips.open({target: $(this)}).setContent("Must be a valid leads to system!");
							$(this).select();
							valid = false;
							return false;
						}
					});
					if (!valid) return false;

					// Validate leads to isn't the viewing system which causes a inner loop
					$.each($("#dialog-signature .leadsTo:visible"), function() {
						if (this.value.length > 0 && this.value.toLowerCase() === sigDialogVM.viewingSystem.name.toLowerCase()) {
							ValidationTooltips.open({target: $(this)}).setContent("Wormhole cannot lead to the same system it comes from!");
							$(this).select();
							valid = false;
							return false;
						}
					});
					if (!valid) return false;

					var payload = {};
					var undo = [];
					if (form.signatureType === "wormhole") {
						var signature = {
							"signatureID": form.signatureID_Alpha + form.signatureID_Numeric,
							"systemID": sigDialogVM.viewingSystemID,
							"type": "wormhole",
							"name": form.wormholeName,
							"lifeLength": form.signatureLength
						};
						var leadsTo = null;
						if (Object.index(tripwire.systems, "name", form.leadsTo, true)) {
							// Leads To is a normal EVE system, so use the sytem ID
							leadsTo = Object.index(tripwire.systems, "name", form.leadsTo, true)
						} else if (tripwire.wormholes[form.wormholeType.toUpperCase()]) {
							// Leads To can be determined by the wormhole type, so lets use what we know it leads to
							if (tripwire.aSigSystems.findIndex((item) => tripwire.wormholes[form.wormholeType.toUpperCase()].leadsTo.replace(' ', '-').toLowerCase() === item.toLowerCase()) > -1) {
								leadsTo = tripwire.aSigSystems.findIndex((item) => tripwire.wormholes[form.wormholeType.toUpperCase()].leadsTo.replace(' ', '-').toLowerCase() === item.toLowerCase());
							}
						} else if (tripwire.aSigSystems.findIndex((item) => form.leadsTo.toLowerCase() === item.toLowerCase()) !== -1) {
							// Leads To is one of the valid types we allow, so use of of those indexes as reference
							leadsTo = tripwire.aSigSystems.findIndex((item) => form.leadsTo.toLowerCase() === item.toLowerCase());
						}
						var signature2 = {
							"signatureID": form.signatureID2_Alpha + form.signatureID2_Numeric,
							"systemID": leadsTo,
							"type": "wormhole",
							"name": form.wormholeName2,
							"lifeLength": form.signatureLength
						};
						var type = null;
						var parent = null;
						if (form.wormholeType.length > 0 && $.inArray(form.wormholeType.toUpperCase(), aSigWormholes) != -1 && form.wormholeType.toUpperCase() != "K162") {
							parent = "initial";
							type = form.wormholeType.toUpperCase();
						} else if (form.wormholeType2.length > 0 && $.inArray(form.wormholeType2.toUpperCase(), aSigWormholes) != -1 && form.wormholeType2.toUpperCase() != "K162") {
							parent = "secondary";
							type = form.wormholeType2.toUpperCase();
						} else if (form.wormholeType.toUpperCase() == "K162") {
							parent = "secondary";
							type = "????";
						} else if (form.wormholeType2.toUpperCase() == "K162") {
							parent = "initial";
							type = "????";
						}
						var wormhole = {
							"type": type,
							"parent": parent,
							"life": form.wormholeLife,
							"mass": form.wormholeMass
						};
						if (sigDialogVM.mode == "update") {
							signature.id = $("#dialog-signature").data("signatureid");
							signature2.id = $("#dialog-signature").data("signature2id");
							wormhole.id = $("#dialog-signature").data("wormholeid");

							// Update the initial and type based on which side of the wormhole we are editing
							if (tripwire.client.wormholes[wormhole.id]) {
								if (form.wormholeType.length > 0 && $.inArray(form.wormholeType.toUpperCase(), aSigWormholes) != -1 && form.wormholeType.toUpperCase() != "K162") {
									wormhole.parent = tripwire.client.wormholes[wormhole.id].initialID == signature.id ? "initial" : "secondary";
									wormhole.type = form.wormholeType.toUpperCase();
								} else if (form.wormholeType2.length > 0 && $.inArray(form.wormholeType2.toUpperCase(), aSigWormholes) != -1 && form.wormholeType2.toUpperCase() != "K162") {
									wormhole.parent = tripwire.client.wormholes[wormhole.id].initialID == signature.id ? "secondary" : "initial";
									wormhole.type = form.wormholeType2.toUpperCase();
								} else if (form.wormholeType.toUpperCase() == "K162") {
									wormhole.parent = tripwire.client.wormholes[wormhole.id].initialID == signature.id ? "secondary" : "initial";
									wormhole.type = "????";
								} else if (form.wormholeType2.toUpperCase() == "K162") {
									wormhole.parent = tripwire.client.wormholes[wormhole.id].initialID == signature.id ? "initial" : "secondary";
									wormhole.type = "????";
								}
							}

							payload = {"signatures": {"update": [{"wormhole": wormhole, "signatures": [signature, signature2]}]}};

							if (tripwire.client.wormholes[wormhole.id]) {
									//used to be a wormhole
									undo.push({"wormhole": tripwire.client.wormholes[wormhole.id], "signatures": [tripwire.client.signatures[signature.id], tripwire.client.signatures[signature2.id]]});
							} else {
									// used to be just a regular signature
									undo.push(tripwire.client.signatures[signature.id]);
							}
						} else {
							payload = {"signatures": {"add": [{"wormhole": wormhole, "signatures": [signature, signature2]}]}};
						}
					} else {
						if (sigDialogVM.mode == "update") {
							var signature = {
								"id": $("#dialog-signature").data("signatureid"),
								"signatureID": form.signatureID_Alpha + form.signatureID_Numeric,
								"systemID": sigDialogVM.viewingSystemID,
								"type": form.signatureType,
								"name": form.signatureName,
								"lifeLength": form.signatureLength
							};
							payload = {"signatures": {"update": [signature]}};

							if (tripwire.client.signatures[signature.id].type == "wormhole") {
								//used to be a wormhole
								var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == signature.id || wormhole.secondaryID == signature.id) return wormhole; })[0];
								var signature2 = signature.id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID];
								undo.push({"wormhole": tripwire.client.wormholes[wormhole.id], "signatures": [tripwire.client.signatures[signature.id], tripwire.client.signatures[signature2.id]]});
							} else {
								// used to be just a regular signature
								undo.push(tripwire.client.signatures[signature.id]);
							}
						} else {
							var signature = {
								"signatureID": form.signatureID_Alpha + form.signatureID_Numeric,
								"systemID": sigDialogVM.viewingSystemID,
								"type": form.signatureType,
								"name": form.signatureName,
								"lifeLength": form.signatureLength
							};
							payload = {"signatures": {"add": [signature]}};
						}
					}

					$("#dialog-signature").parent().find(":button:contains('Save')").button("disable");

					var success = function(data) {
						if (data.resultSet && data.resultSet[0].result == true) {
							$("#dialog-signature").dialog("close");

							$("#undo").removeClass("disabled");

							if (sigDialogVM.mode == "add") {
								undo = data.results;
							}
							if (sigDialogVM.viewingSystemID in tripwire.signatures.undo) {
								tripwire.signatures.undo[sigDialogVM.viewingSystemID].push({action: sigDialogVM.mode, signatures: undo});
							} else {
								tripwire.signatures.undo[sigDialogVM.viewingSystemID] = [{action: sigDialogVM.mode, signatures: undo}];
							}

							sessionStorage.setItem("tripwire_undo", JSON.stringify(tripwire.signatures.undo));
						}
					}

					var always = function() {
						$("#sigEditForm input[type=submit]").removeAttr("disabled");
						$("#dialog-signature").parent().find(":button:contains('Save')").button("enable");
					}

					tripwire.refresh('refresh', payload, success, always);
				});
			},
			open: function() {
				$("#dialog-signature").data("signatureid", "");
				$("#dialog-signature").data("signature2id", "");
				$("#dialog-signature").data("wormholeid", "");

				$("#dialog-signature input").val("");
				$("#dialog-signature [name='signatureType']").val("unknown").selectmenu("refresh");

				$("#dialog-signature [name='wormholeLife']").val("stable").selectmenu("refresh");
				$("#dialog-signature [name='wormholeMass']").val("stable").selectmenu("refresh");

				$("#dialog-signature #site").show();
				$("#dialog-signature #wormhole").hide();

				// Side labels
				$("#dialog-signature .sideLabel:first").html(sigDialogVM.viewingSystem.name + " Side");
				$("#dialog-signature .sideLabel:last").html("Other Side");

				// Default signature life
				$("#dialog-signature #durationPicker").val(options.signatures.pasteLife * 60 * 60).change();

				var id = sigDialogVM.sigId;
				if (sigDialogVM.mode == "update" && id && tripwire.client.signatures[id]) {
					var signature = tripwire.client.signatures[id];
					$("#dialog-signature").data("signatureid", id);

					// Change the dialog buttons
					$("#dialog-signature").parent().find("button:contains('Add')").hide();
					$("#dialog-signature").parent().find("button:contains('Save')").show();

					// Change the dialog title
					$("#dialog-signature").dialog("option", "title", "Edit Signature");

					if (signature.type == "wormhole") {
						var wormhole = $.map(tripwire.client.wormholes, function(wormhole) { if (wormhole.initialID == id || wormhole.secondaryID == id) return wormhole; })[0];
						var otherSignature = id == wormhole.initialID ? tripwire.client.signatures[wormhole.secondaryID] : tripwire.client.signatures[wormhole.initialID];
						$("#dialog-signature").data("signature2id", otherSignature.id);
						$("#dialog-signature").data("wormholeid", wormhole.id);
						
						const sigAlpha = signature.signatureID ? signature.signatureID.substr(0, 3) : "???";
						$("#dialog-signature input[name='signatureID_Alpha']").val(sigAlpha);
						$("#dialog-signature input[name='signatureID_Numeric']").val(signature.signatureID ? signature.signatureID.substr(3, 5) : "");
						$("#dialog-signature [name='signatureType']").val(signature.type).selectmenu("refresh").trigger("selectmenuchange");
						$("#dialog-signature [name='wormholeName']").val(signature.name);
						$("#dialog-signature [name='leadsTo']").val(tripwire.systems[otherSignature.systemID] ? tripwire.systems[otherSignature.systemID].name : (tripwire.aSigSystems[otherSignature.systemID] ? tripwire.aSigSystems[otherSignature.systemID] : ""));

						$("#dialog-signature input[name='signatureID2_Alpha']").val(otherSignature.signatureID ? otherSignature.signatureID.substr(0, 3) : "???");
						$("#dialog-signature input[name='signatureID2_Numeric']").val(otherSignature.signatureID ? otherSignature.signatureID.substr(3, 5) : "");
						$("#dialog-signature [name='wormholeName2']").val(otherSignature.name);
						$("#dialog-signature [name='wormholeLife']").val(wormhole.life).selectmenu("refresh").trigger("selectmenuchange");
						$("#dialog-signature [name='wormholeMass']").val(wormhole.mass).selectmenu("refresh").trigger("selectmenuchange");

						if (wormhole[wormhole.parent+"ID"] == signature.id) {
							$("#dialog-signature input[name='wormholeType']").val(wormhole.type).change();
						} else if (wormhole[wormhole.parent+"ID"] == otherSignature.id) {
							$("#dialog-signature input[name='wormholeType2']").val(wormhole.type).change();
						}
						$("#dialog-signature #durationPicker").val(signature.lifeLength).change();
						
						// Focus the sig ID, if it isn't set, otherwise the sig name
						if(sigAlpha != '???') { $("#dialog-signature input[name='wormholeName']").select(); }
						else { $("#dialog-signature input[name='signatureID_Alpha']").select(); }
					} else {
						$("#dialog-signature input[name='signatureID_Alpha']").val(signature.signatureID ? signature.signatureID.substr(0, 3) : "???");
						$("#dialog-signature input[name='signatureID_Numeric']").val(signature.signatureID ? signature.signatureID.substr(3, 5) : "");
						$("#dialog-signature [name='signatureType']").val(signature.type).selectmenu("refresh").trigger("selectmenuchange");
						$("#dialog-signature [name='signatureName']").val(signature.name);
						$("#dialog-signature #durationPicker").val(signature.lifeLength).change();
						
						// Not a wormhole - always focus the sig ID
						$("#dialog-signature input[name='signatureID_Alpha']").select();
					}

					// Hightlight first ID section, if not set, otherwise the name
				} else {
					// Change the dialog buttons
					$("#dialog-signature").parent().find("button:contains('Add')").show();
					$("#dialog-signature").parent().find("button:contains('Save')").hide();

					// Change the dialog title
					$("#dialog-signature").dialog("option", "title", "Add Signature");

					$("#dialog-signature [name='signatureType']").val(options.signatures.editType || "unknown").selectmenu("refresh")
					if ($("#dialog-signature [name='signatureType']").val() === "wormhole") {
						$("#dialog-signature #site").hide();
						$("#dialog-signature #wormhole").show();
					}
				}
			},
			close: function() {
				ValidationTooltips.close();
				$("#sigTable tr.selected").removeClass("selected");
				$("#dialog-signature").data("signatureid", "");
				$("#dialog-signature").data("signature2id", "");
				$("#dialog-signature").data("wormholeid", "");
			}
		});
	} else if (!$("#dialog-signature").dialog("isOpen")) {
		$("#dialog-signature").dialog("open");
	}
};

const invasions = new _Invasions();
systemAnalysis.addMutator(invasions);

function _Invasions() {
	const _this = this;
	const pathSymbolMap = {
		stellar_reconnaissance: '',
		
		triglavian_minor_victory: '',
		escalating_liminality: '',
		final_liminality: '',
		
		edencom_minor_victory: '',
		redoubt: '', bulwark: '',
		fortress: '',
	};
	const textMap = {
		stellar_reconnaissance: 'Stellar Reconnaissance',
		
		triglavian_minor_victory: 'Triglavian Minor Victory',
		escalating_liminality: 'Escalating Liminality',
		final_liminality: 'Final Liminality',
		
		edencom_minor_victory: 'EDENCOM Minor Victory',
		redoubt: 'Redoubt',
		bulwark: 'Bulwark',
		fortress: 'EDENCOM Fortress',
	}
	
	this.invasions = {};
	
	/** Update the system */
	this.mutate = function(system, systemID) {
		const systemInvasion = this.invasions[systemID];
		if(systemInvasion) {
			if(systemInvasion.derived_security_status) { system.security = 1 * systemInvasion.derived_security_status; }
			system.pathSymbol = pathSymbolMap[systemInvasion.status];
			const tip = textMap[systemInvasion.status] +
				(systemInvasion.derived_security_status ? '<br>Effective security lowered to ' + systemInvasion.derived_security_status : '');
			system.systemTypeModifiers.push('<span class="invasion ' + systemInvasion.status + '" data-tooltip="' + tip + '">' + system.pathSymbol + '</span>');
		}
	}
	
	/** Refresh the invasion data from the public Kybernauts API */
	this.refresh = function() {
		$.ajax({
			url: 'cached_third_party.php?key=invasions',
			type: "GET",
			dataType: "JSON"
		}).done(function(data, status, xhr) {	
			if(!_.isEqual(data, _this.invasions)) {
				console.info('Updating map for invasions update');
				_this.invasions = _.keyBy(data, function(x) { return x.system_id; });
				chain.redraw();
				tripwire.systemChange(viewingSystemID);
			}
		}).fail(function(xhr, status, error) {
			console.warn('Failed to fetch invasion data from kybernaut.space: ' + status, error);
		});
	};
	
	setInterval(this.refresh, 3600000);
	this.refresh();
}
//# sourceMappingURL=app.min.js.map
